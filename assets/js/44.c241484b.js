(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{232:function(v,_,l){"use strict";l.r(_);var i=l(0),t=Object(i.a)({},function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h1",{attrs:{id:"常用建模工具"}},[v._v("常用建模工具")]),v._v(" "),l("h2",{attrs:{id:"uml"}},[v._v("UML")]),v._v(" "),l("p",[v._v("统一建模语言(Unified Modelinig Language, UML)是一种面向对象的建模语言, 它提供一描述软件系统模型的概念和图形表示法, 是一种定义良好, 易于表达, 功能强大且普遍建模语言.")]),v._v(" "),l("h2",{attrs:{id:"uml建模介绍"}},[v._v("UML建模介绍")]),v._v(" "),l("p",[v._v("复杂性, 多样性和相互关联性是各个信息系统的重要特征.")]),v._v(" "),l("p",[v._v('面向对象概念认为客观世界的任何事物都是"对象"')]),v._v(" "),l("p",[v._v("在程序设计中, 对象表达为被描述事物的数据和对数据的处理的统一整体, 也称为封装. 由于对象是封装的, 对象间的联系是通过传递信息实现的.")]),v._v(" "),l("p",[v._v("面向对象方法简称为OO方法, 它由以下3部分组成:")]),v._v(" "),l("ul",[l("li",[v._v("面向对象分析(OOA)")]),v._v(" "),l("li",[v._v("面向对象设计(OOD)")]),v._v(" "),l("li",[v._v("面向对象程序设计(OOP)")])]),v._v(" "),l("h3",{attrs:{id:"面向对象的一些概念"}},[v._v("面向对象的一些概念")]),v._v(" "),l("ul",[l("li",[v._v("对象, 是一些属性和操作行为的封装体")]),v._v(" "),l("li",[v._v("类, 是一组几乎相同的对象的描述")]),v._v(" "),l("li",[v._v("属性, 是以静态的数据组成, 用以描述类和对象所固有的特征, 是类和对象的性质, 并以此来区分不同的类和对象.")]),v._v(" "),l("li",[v._v("抽象, 是人们认识客观世界中复杂性的一种基本方法")]),v._v(" "),l("li",[v._v("封装, 即信息隐藏, 接口部分和实现部分, 对于用户来说接口部分是可见, 具体实用部分则不可见.")]),v._v(" "),l("li",[v._v("方法, 是驻留在对象中的过程")]),v._v(" "),l("li",[v._v("继承, 指对象继承它所在类的结构")]),v._v(" "),l("li",[v._v("消息与多态, 在面向对象方法, 完成一件事情的方法是向有关对象发送消息. 多态是指不同事物具有不同的表现形式的能力. 多态机制使具有不同内部结构的对象可以共享相同的外部接口.")])]),v._v(" "),l("h3",{attrs:{id:"面向对象方法与传递方法相比的优点"}},[v._v("面向对象方法与传递方法相比的优点")]),v._v(" "),l("ul",[l("li",[v._v("它解决了信息系统工程中的两个主要问题: 软件维护的复杂性和提高生产效率")]),v._v(" "),l("li",[v._v("它所表现出来的灵活性和各种性能使软件开发的风险降低.")])]),v._v(" "),l("h3",{attrs:{id:"面向对象的基本过程"}},[v._v("面向对象的基本过程")]),v._v(" "),l("ul",[l("li",[v._v("标识和定义对象及类")]),v._v(" "),l("li",[v._v("组织类间的关系")]),v._v(" "),l("li",[v._v("在类中构造构架")]),v._v(" "),l("li",[v._v("建立可重用的类库和应用程序框架")])]),v._v(" "),l("h3",{attrs:{id:"组件"}},[v._v("组件")]),v._v(" "),l("p",[v._v("组件是一个可重用的软件构件, 一个预先构建的封装的代码模块.")]),v._v(" "),l("p",[v._v("组件的目标是粗粒度的复用, 它的核心是接口.")]),v._v(" "),l("p",[v._v("组件技术是建立在对象技术之上, 它是对象技术的进一步发展.")]),v._v(" "),l("h2",{attrs:{id:"uml基本内容"}},[v._v("UML基本内容")]),v._v(" "),l("p",[v._v("UML把系统开发分成5个阶段:")]),v._v(" "),l("ul",[l("li",[v._v("需求分析")]),v._v(" "),l("li",[v._v("分析")]),v._v(" "),l("li",[v._v("设计")]),v._v(" "),l("li",[v._v("编程")]),v._v(" "),l("li",[v._v("测试")])]),v._v(" "),l("h3",{attrs:{id:"uml的组成"}},[v._v("UML的组成")]),v._v(" "),l("ul",[l("li",[v._v("视图")]),v._v(" "),l("li",[v._v("图表")]),v._v(" "),l("li",[v._v("模型元素")]),v._v(" "),l("li",[v._v("基本机制")])]),v._v(" "),l("h4",{attrs:{id:"视图"}},[v._v("视图")]),v._v(" "),l("ul",[l("li",[v._v("用例视图, 包括用例图, 活动图和顺序图等")]),v._v(" "),l("li",[v._v("逻辑视图\n"),l("ul",[l("li",[v._v("静态关系, 有对象图描述")]),v._v(" "),l("li",[v._v("动态关系, 有状态图, 时序图, 协作图和活动图来描述")])])]),v._v(" "),l("li",[v._v("组件视图, 由组件图组成")]),v._v(" "),l("li",[v._v("配置视图, 由配置图组成")])]),v._v(" "),l("h4",{attrs:{id:"图表"}},[v._v("图表")]),v._v(" "),l("ul",[l("li",[v._v("用例图")]),v._v(" "),l("li",[v._v("类图")]),v._v(" "),l("li",[v._v("对象图")]),v._v(" "),l("li",[v._v("状态图")]),v._v(" "),l("li",[v._v("顺序图")]),v._v(" "),l("li",[v._v("协作图")]),v._v(" "),l("li",[v._v("活动图")]),v._v(" "),l("li",[v._v("组件图")]),v._v(" "),l("li",[v._v("配置图")])]),v._v(" "),l("h4",{attrs:{id:"模型元素"}},[v._v("模型元素")]),v._v(" "),l("h4",{attrs:{id:"基本机制"}},[v._v("基本机制")]),v._v(" "),l("ul",[l("li",[v._v("修饰")]),v._v(" "),l("li",[v._v("注释")]),v._v(" "),l("li",[v._v("说明")])]),v._v(" "),l("h2",{attrs:{id:"rational-rose建模工具介绍"}},[v._v("Rational Rose建模工具介绍")]),v._v(" "),l("p",[v._v("Rational Rose是由三层解决方案组成的应用模型.")]),v._v(" "),l("ul",[l("li",[v._v("用户接口层")]),v._v(" "),l("li",[v._v("事物处理原则层")]),v._v(" "),l("li",[v._v("数据层")])]),v._v(" "),l("h3",{attrs:{id:"建模的主要过程如下"}},[v._v("建模的主要过程如下")]),v._v(" "),l("ul",[l("li",[v._v("确认应用系统的功能要求, 并为事务处理原则建模.")]),v._v(" "),l("li",[v._v("对抽象的对象映射需求, 提供设计模板并创建惯用的模板.")]),v._v(" "),l("li",[v._v("分辨和设计对象或划分三层模型的服务.")]),v._v(" "),l("li",[v._v("对软件的组成部分映射成对象并设计组件在网络上如何分布.")])]),v._v(" "),l("h3",{attrs:{id:"采用rational-rose实现建模所面临的几个问题"}},[v._v("采用Rational Rose实现建模所面临的几个问题")]),v._v(" "),l("ul",[l("li",[v._v("何时需要建模")]),v._v(" "),l("li",[v._v("兼容性问题")]),v._v(" "),l("li",[v._v("对UML的支持程序")]),v._v(" "),l("li",[v._v("对大型项目的特殊支持")]),v._v(" "),l("li",[v._v("采用可视化建模")])]),v._v(" "),l("h3",{attrs:{id:"使用rational-rose进行可视化建模的特点"}},[v._v("使用Rational Rose进行可视化建模的特点")]),v._v(" "),l("ul",[l("li",[v._v("支持UML的建模")]),v._v(" "),l("li",[v._v("采用基于组件的开发")]),v._v(" "),l("li",[v._v("支持多语言开发")]),v._v(" "),l("li",[v._v("支持双向工程.")])]),v._v(" "),l("p",[v._v("这使得使用者可以很容易地完成从系统分析到系统实现, 然后再从系统实现到系统分析的迭代过程.")]),v._v(" "),l("p",[v._v("使用UML建模时, 一般分三部分:")]),v._v(" "),l("ul",[l("li",[v._v("用例视图设计, 主要借助于以下3种图来了解用户的需求\n"),l("ul",[l("li",[v._v("用例图")]),v._v(" "),l("li",[v._v("活动图")]),v._v(" "),l("li",[v._v("状态图")])])]),v._v(" "),l("li",[v._v("逻辑设计, 需要用到:\n"),l("ul",[l("li",[v._v("类图")]),v._v(" "),l("li",[v._v("顺序图")]),v._v(" "),l("li",[v._v("交互图")])])]),v._v(" "),l("li",[v._v("物理设计, 需要借助于:\n"),l("ul",[l("li",[v._v("部署图 等视图")])])])]),v._v(" "),l("h3",{attrs:{id:"uml使用的图解释"}},[v._v("UML使用的图解释")]),v._v(" "),l("ul",[l("li",[v._v("用例图, 主要通过用例来描述系统的功能性需求, 它是系统中与实现无关的视图, 用例视图包括:\n"),l("ul",[l("li",[v._v("角色")]),v._v(" "),l("li",[v._v("用例")]),v._v(" "),l("li",[v._v("关系")])])]),v._v(" "),l("li",[v._v("用例与用例之间的关系有:\n"),l("ul",[l("li",[v._v("扩展关系")]),v._v(" "),l("li",[v._v("包含关系")]),v._v(" "),l("li",[v._v("泛化关系")])])]),v._v(" "),l("li",[v._v("活动图, 本质就是流程图, 它很好地描述了系统的活动, 判定点, 先后顺序和分支等")]),v._v(" "),l("li",[v._v("顺序图, 强调消息时间顺序的交互图")]),v._v(" "),l("li",[v._v("协作图, 强调参加交互的各对象的组织")]),v._v(" "),l("li",[v._v("组件图, 系统组件图描述了软件的各种组件和它们之间的依赖关系. 组件图通常包含三种元素, 即组件, 接口和依赖关系.")]),v._v(" "),l("li",[v._v("类图, 是根据系统中的类, 以及各个类之间的关系描述系统的静态视图, 类由三部分组成:\n"),l("ul",[l("li",[v._v("类名称")]),v._v(" "),l("li",[v._v("类属性")]),v._v(" "),l("li",[v._v("类操作")])])]),v._v(" "),l("li",[v._v("配置图, 可以很好的描述实施时整个系统的结构和层次.")])])])},[],!1,null,null,null);_.default=t.exports}}]);