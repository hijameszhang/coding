<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>TypeScript学习手册 | Web Developer</title>
    <meta name="description" content="Web developer">
    <link rel="shortcut icon" type="icon" href="/coding/coding/images/logo/my.jpg">
    
    <link rel="preload" href="/coding/assets/css/0.styles.9a06647f.css" as="style"><link rel="preload" href="/coding/assets/js/app.bda66ca1.js" as="script"><link rel="preload" href="/coding/assets/js/2.5301b3be.js" as="script"><link rel="preload" href="/coding/assets/js/52.07abf413.js" as="script"><link rel="prefetch" href="/coding/assets/js/10.65e9a4bb.js"><link rel="prefetch" href="/coding/assets/js/11.9e3fd327.js"><link rel="prefetch" href="/coding/assets/js/12.45322000.js"><link rel="prefetch" href="/coding/assets/js/13.91278df4.js"><link rel="prefetch" href="/coding/assets/js/14.24d512d2.js"><link rel="prefetch" href="/coding/assets/js/15.482cbe32.js"><link rel="prefetch" href="/coding/assets/js/16.f2696b58.js"><link rel="prefetch" href="/coding/assets/js/17.4caa8eae.js"><link rel="prefetch" href="/coding/assets/js/18.c623d12e.js"><link rel="prefetch" href="/coding/assets/js/19.ad7b5a63.js"><link rel="prefetch" href="/coding/assets/js/20.effcc9e9.js"><link rel="prefetch" href="/coding/assets/js/21.2ddb2a1f.js"><link rel="prefetch" href="/coding/assets/js/22.70c9ac91.js"><link rel="prefetch" href="/coding/assets/js/23.9f5bec45.js"><link rel="prefetch" href="/coding/assets/js/24.2c097041.js"><link rel="prefetch" href="/coding/assets/js/25.ef69a840.js"><link rel="prefetch" href="/coding/assets/js/26.33c71d45.js"><link rel="prefetch" href="/coding/assets/js/27.9b42ef41.js"><link rel="prefetch" href="/coding/assets/js/28.e1cfa454.js"><link rel="prefetch" href="/coding/assets/js/29.fd9a92f3.js"><link rel="prefetch" href="/coding/assets/js/3.070fe044.js"><link rel="prefetch" href="/coding/assets/js/30.0204da64.js"><link rel="prefetch" href="/coding/assets/js/31.fa7024e0.js"><link rel="prefetch" href="/coding/assets/js/32.67999162.js"><link rel="prefetch" href="/coding/assets/js/33.96063c19.js"><link rel="prefetch" href="/coding/assets/js/34.7efda74e.js"><link rel="prefetch" href="/coding/assets/js/35.a871816e.js"><link rel="prefetch" href="/coding/assets/js/36.37f69431.js"><link rel="prefetch" href="/coding/assets/js/37.26e9bb20.js"><link rel="prefetch" href="/coding/assets/js/38.33dcec0e.js"><link rel="prefetch" href="/coding/assets/js/39.b3a3dae7.js"><link rel="prefetch" href="/coding/assets/js/4.8789dbc3.js"><link rel="prefetch" href="/coding/assets/js/40.ac4acda2.js"><link rel="prefetch" href="/coding/assets/js/41.7e49bde6.js"><link rel="prefetch" href="/coding/assets/js/42.666dbd62.js"><link rel="prefetch" href="/coding/assets/js/43.8976499b.js"><link rel="prefetch" href="/coding/assets/js/44.c241484b.js"><link rel="prefetch" href="/coding/assets/js/45.86cf049d.js"><link rel="prefetch" href="/coding/assets/js/46.f21f338c.js"><link rel="prefetch" href="/coding/assets/js/47.289d9933.js"><link rel="prefetch" href="/coding/assets/js/48.57af0318.js"><link rel="prefetch" href="/coding/assets/js/49.29d5599b.js"><link rel="prefetch" href="/coding/assets/js/5.32ebd2a0.js"><link rel="prefetch" href="/coding/assets/js/50.350b242c.js"><link rel="prefetch" href="/coding/assets/js/51.1cfc7d3f.js"><link rel="prefetch" href="/coding/assets/js/53.587f011d.js"><link rel="prefetch" href="/coding/assets/js/54.9bb24747.js"><link rel="prefetch" href="/coding/assets/js/55.7850accb.js"><link rel="prefetch" href="/coding/assets/js/56.d02b4a21.js"><link rel="prefetch" href="/coding/assets/js/57.099fab41.js"><link rel="prefetch" href="/coding/assets/js/58.13ce710b.js"><link rel="prefetch" href="/coding/assets/js/59.28b0136e.js"><link rel="prefetch" href="/coding/assets/js/6.a94c891c.js"><link rel="prefetch" href="/coding/assets/js/60.022fbb2c.js"><link rel="prefetch" href="/coding/assets/js/61.00fe7075.js"><link rel="prefetch" href="/coding/assets/js/62.6dc716f0.js"><link rel="prefetch" href="/coding/assets/js/63.12b12c53.js"><link rel="prefetch" href="/coding/assets/js/64.2db53cef.js"><link rel="prefetch" href="/coding/assets/js/65.0d7c8758.js"><link rel="prefetch" href="/coding/assets/js/66.010151f5.js"><link rel="prefetch" href="/coding/assets/js/67.8c86ff96.js"><link rel="prefetch" href="/coding/assets/js/7.99d9b27b.js"><link rel="prefetch" href="/coding/assets/js/8.309b23b6.js"><link rel="prefetch" href="/coding/assets/js/9.1df69252.js">
    <link rel="stylesheet" href="/coding/assets/css/0.styles.9a06647f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/coding/" class="home-link router-link-active"><img src="/coding/images/logo/my.jpg" alt="Web Developer" class="logo"> <span class="site-name can-hide">Web Developer</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/coding/vue/" class="nav-link">Vue</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Web</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/coding/css/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/coding/html/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/coding/js/" class="nav-link">JavaScript</a></li><li class="dropdown-item"><!----> <a href="/coding/typescript/" class="nav-link router-link-active">TypeScript</a></li><li class="dropdown-item"><!----> <a href="/coding/vue/" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/coding/nodejs/" class="nav-link">Node.js</a></li><li class="dropdown-item"><!----> <a href="/coding/web/" class="nav-link">Web</a></li><li class="dropdown-item"><!----> <a href="/coding/interview/" class="nav-link">Interview</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Tools</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/coding/git/" class="nav-link">Git</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">BusinessManagement</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/coding/trainer/" class="nav-link">讲师</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/hijameszhang/coding" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/coding/vue/" class="nav-link">Vue</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Web</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/coding/css/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/coding/html/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/coding/js/" class="nav-link">JavaScript</a></li><li class="dropdown-item"><!----> <a href="/coding/typescript/" class="nav-link router-link-active">TypeScript</a></li><li class="dropdown-item"><!----> <a href="/coding/vue/" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/coding/nodejs/" class="nav-link">Node.js</a></li><li class="dropdown-item"><!----> <a href="/coding/web/" class="nav-link">Web</a></li><li class="dropdown-item"><!----> <a href="/coding/interview/" class="nav-link">Interview</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Tools</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/coding/git/" class="nav-link">Git</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">BusinessManagement</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/coding/trainer/" class="nav-link">讲师</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/hijameszhang/coding" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Typescript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/coding/typescript/1-quickStart.html" class="sidebar-link">快速上手</a></li><li><a href="/coding/typescript/2-tsBasic.html" class="active sidebar-link">TypeScript学习手册</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#基础类型" class="sidebar-link">基础类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#布尔值-boolean" class="sidebar-link">布尔值(boolean)</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#数字-number" class="sidebar-link">数字(number)</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#字符串-string" class="sidebar-link">字符串(string)</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#数组" class="sidebar-link">数组</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#元组-tuple" class="sidebar-link">元组(tuple)</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#枚举-enum" class="sidebar-link">枚举(enum)</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#any" class="sidebar-link">any</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#未声明类型的变量" class="sidebar-link">未声明类型的变量</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#类型推断" class="sidebar-link">类型推断</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#void" class="sidebar-link">void</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#null-和-undefined" class="sidebar-link">null 和 undefined</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#never" class="sidebar-link">never</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#object" class="sidebar-link">Object</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#联合类型" class="sidebar-link">联合类型</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#类型断言" class="sidebar-link">类型断言</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#关于let" class="sidebar-link">关于let</a></li></ul></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#类型推论" class="sidebar-link">类型推论</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#基础" class="sidebar-link">基础</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#通用类型" class="sidebar-link">通用类型</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#上下文类型" class="sidebar-link">上下文类型</a></li></ul></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#类型兼容性" class="sidebar-link">类型兼容性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#关于可靠性的注意事项" class="sidebar-link">关于可靠性的注意事项</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#开始" class="sidebar-link">开始</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#比较两个函数" class="sidebar-link">比较两个函数</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#函数参数双向协变" class="sidebar-link">函数参数双向协变</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#可选参数及剩余参数" class="sidebar-link">可选参数及剩余参数</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#函数重载" class="sidebar-link">函数重载</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#枚举" class="sidebar-link">枚举</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#类" class="sidebar-link">类</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#类的私有成员和受保护成员" class="sidebar-link">类的私有成员和受保护成员</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#泛型" class="sidebar-link">泛型</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#高级主题" class="sidebar-link">高级主题</a></li></ul></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#高级类型" class="sidebar-link">高级类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#交叉类型（intersection-types）" class="sidebar-link">交叉类型（Intersection Types）</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#联合类型（union-types）" class="sidebar-link">联合类型（Union Types）</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#类型保护与区分类型（type-guards-and-differentiating-types）" class="sidebar-link">类型保护与区分类型（Type Guards and Differentiating Types）</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#用户自定义的类型保护" class="sidebar-link">用户自定义的类型保护</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#typeof类型保护" class="sidebar-link">typeof类型保护</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#instanceof类型保护" class="sidebar-link">instanceof类型保护</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#可以为null的类型" class="sidebar-link">可以为null的类型</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#可选参数和可选属性" class="sidebar-link">可选参数和可选属性</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#类型保护和类型断言" class="sidebar-link">类型保护和类型断言</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#类型别名" class="sidebar-link">类型别名</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#接口-vs-类型别名" class="sidebar-link">接口 vs. 类型别名</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#字符串字面量类型" class="sidebar-link">字符串字面量类型</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#数字字面量类型" class="sidebar-link">数字字面量类型</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#枚举成员类型" class="sidebar-link">枚举成员类型</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#可辨识联合（discriminated-unions）" class="sidebar-link">可辨识联合（Discriminated Unions）</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#完整性检查" class="sidebar-link">完整性检查</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#多态的-this类型" class="sidebar-link">多态的 this类型</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#索引类型（index-types）" class="sidebar-link">索引类型（Index types）</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#索引类型和字符串索引签名" class="sidebar-link">索引类型和字符串索引签名</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#映射类型" class="sidebar-link">映射类型</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#由映射类型进行推断" class="sidebar-link">由映射类型进行推断</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#预定义的有条件类型" class="sidebar-link">预定义的有条件类型</a></li></ul></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#变量声明" class="sidebar-link">变量声明</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#var声明" class="sidebar-link">var声明</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#let-声明" class="sidebar-link">let 声明</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#const-声明" class="sidebar-link">const 声明</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#let-vs-const" class="sidebar-link">let vs. const</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#解构" class="sidebar-link">解构</a></li></ul></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#接口-interface" class="sidebar-link">接口(interface)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#接口初探" class="sidebar-link">接口初探</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#可选属性" class="sidebar-link">可选属性</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#只读属性" class="sidebar-link">只读属性</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#readon-vs-const" class="sidebar-link">readon vs const</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#属性检查" class="sidebar-link">属性检查</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#函数类型" class="sidebar-link">函数类型</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#可索引的类型" class="sidebar-link">可索引的类型</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#class类型" class="sidebar-link">class类型</a></li></ul></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#类-class" class="sidebar-link">类(class)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#类-2" class="sidebar-link">类</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#继承" class="sidebar-link">继承</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#默认为-public" class="sidebar-link">默认为 public</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#private" class="sidebar-link">private</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#protected" class="sidebar-link">protected</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#readonly修饰符" class="sidebar-link">readonly修饰符</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#参数属性" class="sidebar-link">参数属性</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#存取器" class="sidebar-link">存取器</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#静态属性-static" class="sidebar-link">静态属性(static)</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#抽象类" class="sidebar-link">抽象类</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#构造函数-高级技巧" class="sidebar-link">构造函数(高级技巧)</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#把类当做接口使用" class="sidebar-link">把类当做接口使用</a></li></ul></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#函数-function" class="sidebar-link">函数(function)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#函数" class="sidebar-link">函数</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#函数类型-2" class="sidebar-link">函数类型</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#推断类型" class="sidebar-link">推断类型</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#可选参数和默认参数" class="sidebar-link">可选参数和默认参数</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#剩余参数" class="sidebar-link">剩余参数</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#this" class="sidebar-link">this</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#this和箭头函数" class="sidebar-link">this和箭头函数</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#this参数" class="sidebar-link">this参数</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#this参数在回调函数里" class="sidebar-link">this参数在回调函数里</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#重载" class="sidebar-link">重载</a></li></ul></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#泛型-2" class="sidebar-link">泛型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#泛型之hello-world" class="sidebar-link">泛型之Hello World</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#使用泛型变量" class="sidebar-link">使用泛型变量</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#泛型类型" class="sidebar-link">泛型类型</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#泛型类" class="sidebar-link">泛型类</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#泛型约束" class="sidebar-link">泛型约束</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#在泛型约束中使用类型参数" class="sidebar-link">在泛型约束中使用类型参数</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#在泛型里使用类类型" class="sidebar-link">在泛型里使用类类型</a></li></ul></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#枚举-2" class="sidebar-link">枚举</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#数字枚举" class="sidebar-link">数字枚举</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#字符串枚举" class="sidebar-link">字符串枚举</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#异构枚举（heterogeneous-enums）" class="sidebar-link">异构枚举（Heterogeneous enums）</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#计算的和常量成员" class="sidebar-link">计算的和常量成员</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#联合枚举与枚举成员的类型" class="sidebar-link">联合枚举与枚举成员的类型</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#运行时的枚举" class="sidebar-link">运行时的枚举</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#反向映射" class="sidebar-link">反向映射</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#const枚举" class="sidebar-link">const枚举</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#外部枚举" class="sidebar-link">外部枚举</a></li></ul></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#装饰器" class="sidebar-link">装饰器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#装饰器-2" class="sidebar-link">装饰器</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#装饰器工厂" class="sidebar-link">装饰器工厂</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#装饰器组合" class="sidebar-link">装饰器组合</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#装饰器求值" class="sidebar-link">装饰器求值</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#类装饰器" class="sidebar-link">类装饰器</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#方法装饰器" class="sidebar-link">方法装饰器</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#访问器装饰器" class="sidebar-link">访问器装饰器</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#属性装饰器" class="sidebar-link">属性装饰器</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#参数装饰器" class="sidebar-link">参数装饰器</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#元数据" class="sidebar-link">元数据</a></li></ul></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#mixins" class="sidebar-link">Mixins</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#混入示例" class="sidebar-link">混入示例</a></li></ul></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#模块" class="sidebar-link">模块</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#模块解析" class="sidebar-link">模块解析</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#命名空间" class="sidebar-link">命名空间</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#命名空间和模块" class="sidebar-link">命名空间和模块</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#声明合并" class="sidebar-link">声明合并</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#jsx" class="sidebar-link">JSX</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#三斜线指令" class="sidebar-link">三斜线指令</a></li><li class="sidebar-sub-header"><a href="/coding/typescript/2-tsBasic.html#javascript文件类型检查" class="sidebar-link">JavaScript文件类型检查</a></li></ul></li><li><a href="/coding/typescript/3-javascriptTranser.html" class="sidebar-link">JavaScript迁移</a></li><li><a href="/coding/typescript/4-vue-webpack-ts.html" class="sidebar-link">Vue &amp; TypeScript</a></li><li><a href="/coding/typescript/5-react-webpack.html" class="sidebar-link">React &amp; Webpack</a></li><li><a href="/coding/typescript/6-project-config.html" class="sidebar-link">项目配置</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="typescript学习手册">TypeScript学习手册</h1> <blockquote><p>本文摘至https://www.tslang.cn/docs/home.html</p></blockquote> <h2 id="基础类型">基础类型</h2> <p>为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p> <h3 id="布尔值-boolean">布尔值(boolean)</h3> <p>最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean（其它语言中也一样）。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> isDone<span class="token punctuation">:</span> boolean <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="数字-number">数字(number)</h3> <p>和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> decLiteral<span class="token punctuation">:</span> number <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> hexLiteral<span class="token punctuation">:</span> number <span class="token operator">=</span> <span class="token number">0xf00d</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> binaryLiteral<span class="token punctuation">:</span> number <span class="token operator">=</span> <span class="token number">0b1010</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> octalLiteral<span class="token punctuation">:</span> number <span class="token operator">=</span> <span class="token number">0o744</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="字符串-string">字符串(string)</h3> <p>TypeScript使用string表示文本数据类型。 和JavaScript一样，可以使用双引号（ &quot;）或单引号（'）表示字符串。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> name<span class="token punctuation">:</span> string <span class="token operator">=</span> <span class="token string">&quot;james&quot;</span><span class="token punctuation">;</span>
name <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">;</span>
</code></pre></div><p>当然, 也可以使用<strong>模板字符串</strong>, 可以定义多行文本和内嵌表达式. 如:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> name<span class="token punctuation">:</span> string <span class="token operator">=</span> <span class="token template-string"><span class="token string">`Gene`</span></span><span class="token punctuation">;</span>
<span class="token keyword">let</span> age<span class="token punctuation">:</span> number <span class="token operator">=</span> <span class="token number">37</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> sentence<span class="token punctuation">:</span> string <span class="token operator">=</span> <span class="token template-string"><span class="token string">`Hello, my name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> name <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.

I'll be </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> age <span class="token operator">+</span> <span class="token number">1</span> <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> years old next month.`</span></span><span class="token punctuation">;</span>
</code></pre></div><h3 id="数组">数组</h3> <p>TypeScript和JavaScript一样, 可以操作数组元素, 有两种方式定义数组:</p> <ul><li>在元素类型后面加上 <code>[]</code></li> <li>使用数组泛型 <code>Array&lt;元素类型&gt;</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> list<span class="token punctuation">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token comment">// 或者</span>
<span class="token keyword">let</span> list<span class="token punctuation">:</span> Array<span class="token operator">&lt;</span>number<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
</code></pre></div><h3 id="元组-tuple">元组(tuple)</h3> <p>元组类型允许表示一个已知元素数量和类型的数组, 各元素的类型不必相同. 如, 你可以定义一对值分别为 string 和 number类型的元组.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> x<span class="token punctuation">:</span> <span class="token punctuation">[</span>string<span class="token punctuation">,</span> number<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// init it</span>
x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'hello'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
<span class="token comment">// init it incorrectly</span>
x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'hello'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
</code></pre></div><p>当访问一个已经索引的元素,会得到正确的类型.</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error, 'number'类型类型的对象没有'substr'方法</span>
</code></pre></div><p>当访问一个越界的元素, 会使用联合类型替代.</p> <div class="language-js extra-class"><pre class="language-js"><code>x<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'world'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// ok, 'string'和'number'都有toString方法</span>
x<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// Error, 布尔不是{string | number }类型</span>
</code></pre></div><p>联合类型是高级主题, 会在以后的章节里讨论它.</p> <h3 id="枚举-enum">枚举(enum)</h3> <p><code>enum</code>类型是对JavaScript标准数据类型的一个补充, 像C#等其他语言一样, 使用枚举类型可以为一组数值赋予友好的名字.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">enum</span> Color <span class="token punctuation">{</span>Red<span class="token punctuation">,</span> Green<span class="token punctuation">,</span> Blue<span class="token punctuation">}</span>
<span class="token keyword">let</span> c<span class="token punctuation">:</span>Color <span class="token operator">=</span> Color<span class="token punctuation">.</span>Green<span class="token punctuation">;</span>
</code></pre></div><p>默认情况下, 从0开始为元素编号, 你也可以手动的指定成员的数值. 例如, 我们将上面的例子改从1开始编号.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">enum</span> Color <span class="token punctuation">{</span>Red <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> Green<span class="token punctuation">,</span> Blue<span class="token punctuation">}</span>
<span class="token keyword">let</span> c<span class="token punctuation">:</span>Color <span class="token operator">=</span> Color<span class="token punctuation">.</span>Green<span class="token punctuation">;</span>
</code></pre></div><p>或者, 全部都采用手动赋值</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">enum</span> Color <span class="token punctuation">{</span>Red <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> Green <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> Blue <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> c<span class="token punctuation">:</span>Color <span class="token operator">=</span> Color<span class="token punctuation">.</span>Green<span class="token punctuation">;</span>
</code></pre></div><p>枚举类型提供的一个便利是, 你可以由枚举的值得到它的名字. 例如, 我们知道数值为2, 但是不确定它映射到Color里的哪个名字, 我们可以查找相应的名字.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">enum</span> Color <span class="token punctuation">{</span>Red <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> Green<span class="token punctuation">,</span> Blue<span class="token punctuation">}</span>
<span class="token keyword">let</span> colorName<span class="token punctuation">:</span> string <span class="token operator">=</span> Color<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>colorName<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 显示'Green'因为上面代码里它的值是2</span>
</code></pre></div><h3 id="any">any</h3> <p>有时, 我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型, 这些值可能来自于动态的内容.
例如, 来自用户输入或第三方代码库.</p> <p>在这种情况下, 我们不希望类型检查器对这些值进行检查, 而是直接让它们通过编译阶段的检查. 此时, 我们可以使用<code>any</code>类型来标记这些变量.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> notSure<span class="token punctuation">:</span> any <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
notSure <span class="token operator">=</span> <span class="token string">&quot;maybe a string instead&quot;</span><span class="token punctuation">;</span>
notSure <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// okay, definitely a boolean</span>
</code></pre></div><p>在对现有代码进行改写的时候, <code>any</code>类型是十分有用的, 它允许你在编译时可选择地包含或移除类型检查. 你可能认为<code>Object</code>有相似的作用, 就像它在其它语言中那样. 但是<code>Object</code>类型的变量只是允许你给它赋任意值, 但是却不能够在它上面调用任意的方法, 即便它真的有这些方法.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> notSure<span class="token punctuation">:</span> any <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
notSure<span class="token punctuation">.</span><span class="token function">ifItExists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok, ifItExists方法在运行时可能会存在</span>
notSure<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok, toFixed存在, 但编译器不会云检查它</span>

<span class="token keyword">let</span> prettySure<span class="token punctuation">:</span> Object <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
prettySure<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error, prettySure对象不存在属性&quot;toFixed&quot;</span>
</code></pre></div><p>当你只知道一部分数据类型时, <code>any</code>类型也是有用的. 比如, 你有一个数组, 它包含了不同的类型的数据:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> list<span class="token punctuation">:</span> any<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token string">&quot;free&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="未声明类型的变量">未声明类型的变量</h3> <p>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> hello<span class="token punctuation">;</span>
hello <span class="token operator">=</span> <span class="token string">'james'</span><span class="token punctuation">;</span>
hello <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>

hello<span class="token punctuation">.</span><span class="token function">world</span><span class="token punctuation">(</span><span class="token string">'James'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>等价于</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> hello<span class="token punctuation">:</span> any<span class="token punctuation">;</span>
hello <span class="token operator">=</span> <span class="token string">'james'</span><span class="token punctuation">;</span>
hello <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>

hello<span class="token punctuation">.</span><span class="token function">world</span><span class="token punctuation">(</span><span class="token string">'James'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="类型推断">类型推断</h3> <p>若在变量声明时, 没有指定类型, TypeScript会依据类型推断出一个类型.</p> <p>例如:
以下代码虽然没有指定类型，但是会在编译的时候报错：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> hello <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">;</span>
</code></pre></div><p>等价于:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> hello<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
hello <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span>
</code></pre></div><p>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> hello<span class="token punctuation">;</span>
hello <span class="token operator">=</span> <span class="token string">'world'</span><span class="token punctuation">;</span>
hello <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre></div><p>等价于:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> hello<span class="token punctuation">:</span> any<span class="token punctuation">;</span>
hello <span class="token operator">=</span> <span class="token string">'world'</span><span class="token punctuation">;</span>
hello <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="void">void</h3> <p><code>void</code>类型像是与<code>any</code>类型相反, 它表示没有任何类型, 当一个函数没有返回值时, 你通常会见到其返回值类型是<code>void</code>:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">warnUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;This is my warning message&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>声明一个<code>void</code>类型的变量没有什么大用, 因为你只能为它赋予<code>undefined</code>和<code>null</code>;</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> unusable<span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="null-和-undefined">null 和 undefined</h3> <p>TypeScript里, <code>undefined</code>和<code>null</code>两者各自有自己的类型, 分别是 <code>undefined</code>和<code>null</code>, 和<code>void</code>相似, 它们的本身的类型不是很大.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> u<span class="token punctuation">:</span> <span class="token keyword">undefined</span> <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> n<span class="token punctuation">:</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre></div><p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型, 意即你可以把<code>null</code>和<code>undefined</code>赋值给<code>number</code>类型的变量.</p> <p>然而, 当你指定了<code>--strictNullChecks</code>标记时, <code>null</code>和<code>undefined</code>只能赋值给<code>void</code>和它们各自.
这能避免很多常见的问题, 也许在某处你想传入一个<code>string</code>或<code>null</code>或<code>undefined</code>, 你可以使用联合类型 <code>string</code> | <code>null</code> | <code>undefined</code>.</p> <div class="tip custom-block"><p class="custom-block-title">推荐</p> <p>尽可能地使用--strictNullChecks。</p></div> <h3 id="never">never</h3> <p><code>never</code>类型表示的是那些永不存在的值的类型. 例如: <code>never</code>类型是那些会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型.</p> <p>变量也可能是<code>never</code>类型, 当它们被永不为真的类型保护所约束时.</p> <p><code>never</code>类型是任何类型的子类型, 也可以赋值给任何类型; 然而, 没有类型是<code>never</code>的子类型或可以赋值给<code>never</code>类型(除了<code>never</code>本身之外), 即使<code>any</code>也不可以赋值给<code>never</code>.</p> <p>下面是一些返回<code>never</code>类型的函数示例:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 返回never的函数必须存在无法达到的终点</span>
<span class="token keyword">function</span> <span class="token function">error</span><span class="token punctuation">(</span><span class="token parameter">message<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span><span class="token punctuation">:</span> never <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 推断的返回值类型为never</span>
<span class="token keyword">function</span> <span class="token function">fail</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;Something failed&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 返回never的函数必须存在无法达到的终点</span>
<span class="token keyword">function</span> <span class="token function">infiniteLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> never <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="object">Object</h3> <p><code>object</code>表示非原始类型，也就是除:</p> <ul><li><code>number</code></li> <li><code>string</code></li> <li><code>boolean</code></li> <li><code>symbol</code></li> <li><code>null</code></li> <li><code>undefined</code>
之外的类型。</li></ul> <p>使用<code>object</code>类型，就可以更好的表示像<code>Object.create</code>这样的<code>API</code>。例如：</p> <div class="language-js extra-class"><pre class="language-js"><code>declare <span class="token keyword">function</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token parameter">o<span class="token punctuation">:</span> object <span class="token operator">|</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>

<span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">{</span> prop<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK</span>
<span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK</span>

<span class="token function">create</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
<span class="token function">create</span><span class="token punctuation">(</span><span class="token string">&quot;string&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
<span class="token function">create</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
<span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
</code></pre></div><h3 id="联合类型">联合类型</h3> <p>联合类型（Union Types）表示取值可以为多种类型中的一种。
例如:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> hello<span class="token punctuation">:</span> string <span class="token operator">|</span> number<span class="token punctuation">;</span>
hello <span class="token operator">=</span> <span class="token string">'world'</span><span class="token punctuation">;</span>
hello <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> hello<span class="token punctuation">:</span> string <span class="token operator">|</span> number<span class="token punctuation">;</span>
hello <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre></div><p>此时TypeScript会编译出错:</p> <div class="language- extra-class"><pre class="language-text"><code>demo.ts(2,1): error TS2322: Type 'boolean' is not assignable to type 'string | number'.
Type 'boolean' is not assignable to type 'number'.
</code></pre></div><p>联合类型使用 <code>|</code> 分隔每个类型。例如:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> hello<span class="token punctuation">:</span> string <span class="token operator">|</span> number<span class="token punctuation">;</span>
<span class="token comment">// 允许 hello 的类型是 string 或者 number，但是不能是其他类型。</span>
</code></pre></div><p>访问联合类型的属性或方法
当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">getLength</span><span class="token punctuation">(</span><span class="token parameter">something<span class="token punctuation">:</span> string <span class="token operator">|</span> number</span><span class="token punctuation">)</span><span class="token punctuation">:</span> number <span class="token punctuation">{</span>
    <span class="token keyword">return</span> something<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>此时编译会出错, 因为<code>string</code>与<code>number</code>的不存在共有属性<code>length</code>. 访问 <code>string</code> 和 <code>number</code> 的共有属性(如: <code>toString方法</code>是没问题的</p> <div class="language- extra-class"><pre class="language-text"><code>demo.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.
 Property 'length' does not exist on type 'number'.
</code></pre></div><p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> hello<span class="token punctuation">:</span> string <span class="token operator">|</span> number<span class="token punctuation">;</span>
hello <span class="token operator">=</span> <span class="token string">'world'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>hello<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5</span>
hello <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>hello<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error TS2339: Property 'length' does not exist on type 'number'.</span>
</code></pre></div><p>此例中，第二行的 <code>hello</code> 被推断成了 <code>string</code>，访问它的 <code>length</code> 属性不会报错。
而第四行的 <code>hello</code> 被推断成了 <code>number</code>，访问它的 <code>length</code> 属性时就报错了。</p> <h3 id="类型断言">类型断言</h3> <p>有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p> <p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。</p> <p>类型断言有两种形式。 其一是“尖括号”语法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> someValue<span class="token punctuation">:</span> any <span class="token operator">=</span> <span class="token string">&quot;this is a string&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> strLength<span class="token punctuation">:</span> number <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>string<span class="token operator">&gt;</span>someValue<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
</code></pre></div><p>另一个为as语法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> someValue<span class="token punctuation">:</span> any <span class="token operator">=</span> <span class="token string">&quot;this is a string&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> strLength<span class="token punctuation">:</span> number <span class="token operator">=</span> <span class="token punctuation">(</span>someValue <span class="token keyword">as</span> string<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
</code></pre></div><p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；</p> <div class="warning custom-block"><p>当你在TypeScript里使用JSX时，只有 as语法断言是被允许的。</p></div> <h3 id="关于let">关于let</h3> <p>我们使用let关键字来代替大家所熟悉的JavaScript关键字<code>var</code>。
<code>let</code>关键字是JavaScript的一个新概念，TypeScript实现了它。
我们会在以后详细介绍它，很多常见的问题都可以通过使用 let来解决，所以尽可能地使用let来代替var吧。</p> <div class="tip custom-block"><p>在TypeScript中, 尽可能地使用<code>let</code>来代替<code>var</code></p></div> <h2 id="类型推论">类型推论</h2> <h3 id="基础">基础</h3> <p>TypeScript里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。例如:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
</code></pre></div><p>变量x的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。</p> <p>大多数情况下，类型推论是直截了当的。</p> <h3 id="通用类型">通用类型</h3> <p>当需要从几个表达式中推断类型时候，会使用这些表达式的类型来推断出一个最合适的通用类型。例如，</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>为了推断x的类型，我们必须考虑所有元素的类型。 这里有两种选择： <code>number</code>和<code>null</code>。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。</p> <p>由于最终的通用类型取自候选类型，有些时候候选类型共享相同的通用类型，但是却没有一个类型能做为所有候选类型的类型。例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> zoo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">Rhino</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Elephant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Snake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>这里，我们想让zoo被推断为Animal[]类型，但是这个数组里没有对象是Animal类型的，因此不能推断出这个结果。 为了更正，当候选类型不能使用的时候我们需要明确的指出类型：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> zoo<span class="token punctuation">:</span> Animal<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">Rhino</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Elephant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Snake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，<code>(Rhino | Elephant | Snake)[]</code>。</p> <h3 id="上下文类型">上下文类型</h3> <p>TypeScript类型推论也可能按照相反的方向进行。 这被叫做“按上下文归类”。按上下文归类会发生在表达式的类型与所处的位置相关时。比如：</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function-variable function">onmousedown</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">mouseEvent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mouseEvent<span class="token punctuation">.</span>button<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//&lt;- Error</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>这个例子会得到一个类型错误，TypeScript类型检查器使用<code>window.onmousedown</code>函数的类型来推断右边函数表达式的类型。 因此，就能推断出 <code>mouseEvent</code>参数的类型了。 如果函数表达式不是在上下文类型的位置， <code>mouseEvent</code>参数的类型需要指定为<code>any</code>，这样也不会报错了。</p> <p>如果上下文类型表达式包含了明确的类型信息，上下文的类型被忽略。 重写上面的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function-variable function">onmousedown</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">mouseEvent<span class="token punctuation">:</span> any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mouseEvent<span class="token punctuation">.</span>button<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//&lt;- Now, no error is given</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>这个函数表达式有明确的参数类型注解，上下文类型被忽略。 这样的话就不报错了，因为这里不会使用到上下文类型。</p> <p>上下文归类会在很多情况下使用到。 通常包含函数的参数，赋值表达式的右边，类型断言，对象成员和数组字面量和返回值语句。 上下文类型也会做为最佳通用类型的候选类型。比如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createZoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Animal<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">Rhino</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Elephant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Snake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个例子里，最佳通用类型有4个候选者：<code>Animal</code>，<code>Rhin</code>o，<code>Elephant</code>和<code>Snake</code>。 当然， Animal会被做为最佳通用类型。</p> <h2 id="类型兼容性">类型兼容性</h2> <p>TypeScript里的类型兼容性是基于结构子类型的。
结构类型是一种只使用其成员来描述类型的方式。 它正好与名义（nominal）类型形成对比。（译者注：在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明和/或类型的名称来决定的。这与结构性类型系统不同，它是基于类型的组成结构，且不要求明确地声明。）</p> <p>例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">Named</span> <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> p<span class="token punctuation">:</span> Named<span class="token punctuation">;</span>
<span class="token comment">// OK, because of structural typing</span>
p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在使用基于名义类型的语言，比如C#或Java中，这段代码会报错，因为Person类没有明确说明其实现了Named接口。</p> <p>TypeScript的结构性子类型是根据JavaScript代码的典型写法来设计的。 因为JavaScript里广泛地使用匿名对象，例如函数表达式和对象字面量，所以使用结构类型系统来描述这些类型比使用名义类型系统更好。</p> <h3 id="关于可靠性的注意事项">关于可靠性的注意事项</h3> <p>TypeScript的类型系统允许某些在编译阶段无法确认其安全性的操作。
当一个类型系统具此属性时，被当做是“不可靠”的。TypeScript允许这种不可靠行为的发生是经过仔细考虑的。通过这篇文章，我们会解释什么时候会发生这种情况和其有利的一面。</p> <h3 id="开始">开始</h3> <div class="tip custom-block"><p class="custom-block-title">TypeScript结构化类型系统的基本规则</p> <p>如果<code>x</code>要兼容<code>y</code>，那么<code>y</code>至少具有与<code>x</code>相同的属性。比如：</p></div> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">Named</span> <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> x<span class="token punctuation">:</span> Named<span class="token punctuation">;</span>
<span class="token comment">// y's inferred type is { name: string; location: string; }</span>
<span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Alice'</span><span class="token punctuation">,</span> location<span class="token punctuation">:</span> <span class="token string">'Seattle'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
x <span class="token operator">=</span> y<span class="token punctuation">;</span>
</code></pre></div><p>这里要检查<code>y</code>是否能赋值给<code>x</code>，编译器检查<code>x</code>中的每个属性，看是否能在<code>y</code>中也找到对应属性。
在这个例子中，<code>y</code>必须包含名字是<code>name</code>的<code>string</code>类型成员。<code>y</code>满足条件，因此赋值正确。</p> <p>检查函数参数时使用相同的规则：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">greet</span><span class="token punctuation">(</span><span class="token parameter">n<span class="token punctuation">:</span> Named</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hello, '</span> <span class="token operator">+</span> n<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">greet</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK</span>
</code></pre></div><p>注意，<code>y</code>有个额外的<code>location</code>属性，但这不会引发错误。 只有目标类型（这里是<code>Named</code>）的成员会被一一检查是否兼容。</p> <p>这个比较过程是递归进行的，检查每个成员及子成员。</p> <h3 id="比较两个函数">比较两个函数</h3> <p>相对来讲，在比较原始类型和对象类型的时候是比较容易理解的，问题是如何判断两个函数是兼容的。
下面我们从两个简单的函数入手，它们仅是参数列表略有不同：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">x</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">:</span> number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token function-variable function">y</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">b<span class="token punctuation">:</span> number<span class="token punctuation">,</span> s<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>

y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// OK</span>
x <span class="token operator">=</span> y<span class="token punctuation">;</span> <span class="token comment">// Error</span>
</code></pre></div><p>要查看<code>x</code>是否能赋值给<code>y</code>，首先看它们的参数列表。 <code>x</code>的每个参数必须能在<code>y</code>里找到对应类型的参数。
注意的是参数的名字相同与否无所谓，只看它们的类型。 这里，<code>x</code>的每个参数在<code>y</code>中都能找到对应的参数，所以允许赋值。</p> <p>第二个赋值错误，因为<code>y</code>有个必需的第二个参数，但是<code>x</code>并没有，所以不允许赋值。</p> <p>你可能会疑惑为什么允许忽略参数，像例子<code>y = x</code>中那样。 原因是忽略额外的参数在JavaScript里是很常见的。
例如，<code>Array#forEach</code>给回调函数传3个参数：数组元素，索引和整个数组。 尽管如此，传入一个只使用第一个参数的回调函数也是很有用的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// Don't force these extra arguments</span>
items<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index<span class="token punctuation">,</span> array</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Should be OK!</span>
items<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>下面来看看如何处理返回值类型，创建两个仅是返回值类型不同的函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">x</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">'Alice'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token function-variable function">y</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">'Alice'</span><span class="token punctuation">,</span> location<span class="token punctuation">:</span> <span class="token string">'Seattle'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

x <span class="token operator">=</span> y<span class="token punctuation">;</span> <span class="token comment">// OK</span>
y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// Error, because x() lacks a location property</span>
</code></pre></div><p>类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型。</p> <h3 id="函数参数双向协变">函数参数双向协变</h3> <p>当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。
这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了不是那么精确的类型信息。
实际上，这极少会发生错误，并且能够实现很多JavaScript里的常见模式。例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">enum</span> EventType <span class="token punctuation">{</span> Mouse<span class="token punctuation">,</span> Keyboard <span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Event</span> <span class="token punctuation">{</span> timestamp<span class="token punctuation">:</span> number<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">MouseEvent</span> <span class="token keyword">extends</span> <span class="token class-name">Event</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> number<span class="token punctuation">;</span> y<span class="token punctuation">:</span> number <span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">KeyEvent</span> <span class="token keyword">extends</span> <span class="token class-name">Event</span> <span class="token punctuation">{</span> keyCode<span class="token punctuation">:</span> number <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">listenEvent</span><span class="token punctuation">(</span>eventType<span class="token punctuation">:</span> EventType<span class="token punctuation">,</span> <span class="token function-variable function">handler</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter">n<span class="token punctuation">:</span> Event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span>

<span class="token comment">// Unsound, but useful and common</span>
<span class="token function">listenEvent</span><span class="token punctuation">(</span>EventType<span class="token punctuation">.</span>Mouse<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e<span class="token punctuation">:</span> MouseEvent</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token string">','</span> <span class="token operator">+</span> e<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Undesirable alternatives in presence of soundness</span>
<span class="token function">listenEvent</span><span class="token punctuation">(</span>EventType<span class="token punctuation">.</span>Mouse<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e<span class="token punctuation">:</span> Event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>MouseEvent<span class="token operator">&gt;</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token string">','</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>MouseEvent<span class="token operator">&gt;</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">listenEvent</span><span class="token punctuation">(</span>EventType<span class="token punctuation">.</span>Mouse<span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token parameter">e<span class="token punctuation">:</span> Event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">e<span class="token punctuation">:</span> MouseEvent</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token string">','</span> <span class="token operator">+</span> e<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Still disallowed (clear error). Type safety enforced for wholly incompatible types</span>
<span class="token function">listenEvent</span><span class="token punctuation">(</span>EventType<span class="token punctuation">.</span>Mouse<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e<span class="token punctuation">:</span> number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="可选参数及剩余参数">可选参数及剩余参数</h3> <p>比较函数兼容性的时候，可选参数与必须参数是可互换的。
源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误。</p> <p>当一个函数有剩余参数时，它被当做无限个可选参数。</p> <p>这对于类型系统来说是不稳定的，但从运行时的角度来看，可选参数一般来说是不强制的，因为对于大多数函数来说相当于传递了一些undefinded。</p> <p>有一个好的例子，常见的函数接收一个回调函数并用对于程序员来说是可预知的参数但对类型系统来说是不确定的参数来调用：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">invokeLater</span><span class="token punctuation">(</span>args<span class="token punctuation">:</span> any<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function-variable function">callback</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args<span class="token punctuation">:</span> any<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... Invoke callback with 'args' ... */</span>
<span class="token punctuation">}</span>

<span class="token comment">// Unsound - invokeLater &quot;might&quot; provide any number of arguments</span>
<span class="token function">invokeLater</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token string">', '</span> <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Confusing (x and y are actually required) and undiscoverable</span>
<span class="token function">invokeLater</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">x<span class="token operator">?</span><span class="token punctuation">,</span> y<span class="token operator">?</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token string">', '</span> <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="函数重载">函数重载</h3> <p>对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。
这确保了目标函数可以在所有源函数可调用的地方调用。</p> <h3 id="枚举">枚举</h3> <p>枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的。比如，</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">enum</span> Status <span class="token punctuation">{</span> Ready<span class="token punctuation">,</span> Waiting <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">enum</span> Color <span class="token punctuation">{</span> Red<span class="token punctuation">,</span> Blue<span class="token punctuation">,</span> Green <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> status <span class="token operator">=</span> Status<span class="token punctuation">.</span>Ready<span class="token punctuation">;</span>
status <span class="token operator">=</span> Color<span class="token punctuation">.</span>Green<span class="token punctuation">;</span>  <span class="token comment">// Error</span>
</code></pre></div><h3 id="类">类</h3> <p>类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型。
比较两个类类型的对象时，只有实例的成员会被比较。 <strong>静态成员和构造函数不在比较的范围内。</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    feet<span class="token punctuation">:</span> number<span class="token punctuation">;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">:</span> string<span class="token punctuation">,</span> numFeet<span class="token punctuation">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Size</span> <span class="token punctuation">{</span>
    feet<span class="token punctuation">:</span> number<span class="token punctuation">;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">numFeet<span class="token punctuation">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> a<span class="token punctuation">:</span> Animal<span class="token punctuation">;</span>
<span class="token keyword">let</span> s<span class="token punctuation">:</span> Size<span class="token punctuation">;</span>

a <span class="token operator">=</span> s<span class="token punctuation">;</span>  <span class="token comment">// OK</span>
s <span class="token operator">=</span> a<span class="token punctuation">;</span>  <span class="token comment">// OK</span>
</code></pre></div><h3 id="类的私有成员和受保护成员">类的私有成员和受保护成员</h3> <p>类的私有成员和受保护成员会影响兼容性。
当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。
同样地，这条规则也适用于包含受保护成员实例的类型检查。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。</p> <h3 id="泛型">泛型</h3> <p>因为TypeScript是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。比如，</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">Empty</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> x<span class="token punctuation">:</span> Empty<span class="token operator">&lt;</span>number<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y<span class="token punctuation">:</span> Empty<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">;</span>

x <span class="token operator">=</span> y<span class="token punctuation">;</span>  <span class="token comment">// OK, because y matches structure of x</span>
</code></pre></div><p>上面代码里，<code>x</code>和<code>y</code>是兼容的，因为它们的结构使用类型参数时并没有什么不同。 把这个例子改变一下，增加一个成员，就能看出是如何工作的了：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">NotEmpty</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    data<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> x<span class="token punctuation">:</span> NotEmpty<span class="token operator">&lt;</span>number<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y<span class="token punctuation">:</span> NotEmpty<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">;</span>

x <span class="token operator">=</span> y<span class="token punctuation">;</span>  <span class="token comment">// Error, because x and y are not compatible</span>
</code></pre></div><p>在这里，泛型类型在使用时就好比不是一个泛型类型。</p> <p>对于没指定泛型类型的泛型参数时，会把所有泛型参数当成any比较。 然后用结果类型进行比较，就像上面第一个例子。</p> <p>比如，</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">identity</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> <span class="token function-variable function">reverse</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">&lt;</span><span class="token constant">U</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>y<span class="token punctuation">:</span> <span class="token constant">U</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token constant">U</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

identity <span class="token operator">=</span> reverse<span class="token punctuation">;</span>  <span class="token comment">// OK, because (x: any) =&gt; any matches (y: any) =&gt; any</span>
</code></pre></div><h3 id="高级主题">高级主题</h3> <h4 id="子类型与赋值">子类型与赋值</h4> <p>目前为止，我们使用了“兼容性”，它在语言规范里没有定义。
在TypeScript里，有两种兼容性：子类型和赋值。 它们的不同点在于，赋值扩展了子类型兼容性，增加了一些规则，允许和any来回赋值，以及enum和对应数字值之间的来回赋值。</p> <p>语言里的不同地方分别使用了它们之中的机制。 实际上，类型兼容性是由赋值兼容性来控制的，即使在implements和extends语句也不例外。</p> <p>更多信息，请参阅<a href="https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md" target="_blank" rel="noopener noreferrer">TypeScript语言规范<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>.</p> <h2 id="高级类型">高级类型</h2> <h3 id="交叉类型（intersection-types）">交叉类型（Intersection Types）</h3> <p>交叉类型是将多个类型合并为一个类型。
这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。
例如， Person &amp; Serializable &amp; Loggable同时是 Person 和 Serializable 和 Loggable。
就是说这个类型的对象同时拥有了这三种类型的成员。</p> <p>我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在JavaScript里发生这种情况的场合很多！）
下面是如何创建混入的一个简单例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> extend<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>first<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> second<span class="token punctuation">:</span> <span class="token constant">U</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token constant">T</span> <span class="token operator">&amp;</span> <span class="token constant">U</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">&amp;</span> <span class="token constant">U</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> id <span class="token keyword">in</span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">(</span><span class="token operator">&lt;</span>any<span class="token operator">&gt;</span>result<span class="token punctuation">)</span><span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>any<span class="token operator">&gt;</span>first<span class="token punctuation">)</span><span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> id <span class="token keyword">in</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>result<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token punctuation">(</span><span class="token operator">&lt;</span>any<span class="token operator">&gt;</span>result<span class="token punctuation">)</span><span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>any<span class="token operator">&gt;</span>second<span class="token punctuation">)</span><span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">public</span> name<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">Loggable</span> <span class="token punctuation">{</span>
    <span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">ConsoleLogger</span> <span class="token keyword">implements</span> <span class="token class-name">Loggable</span> <span class="token punctuation">{</span>
    <span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> jim <span class="token operator">=</span> <span class="token function">extend</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Jim&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ConsoleLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> n <span class="token operator">=</span> jim<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
jim<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="联合类型（union-types）">联合类型（Union Types）</h3> <p>联合类型与交叉类型很有关联，但是使用上却完全不同。
偶尔你会遇到这种情况，一个代码库希望传入 number或 string类型的参数。
例如下面的函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Takes a string and adds &quot;padding&quot; to the left.
 * If 'padding' is a string, then 'padding' is appended to the left side.
 * If 'padding' is a number, then that number of spaces is added to the left side.
 */</span>
<span class="token keyword">function</span> <span class="token function">padLeft</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">:</span> string<span class="token punctuation">,</span> padding<span class="token punctuation">:</span> any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> padding <span class="token operator">===</span> <span class="token string">&quot;number&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">Array</span><span class="token punctuation">(</span>padding <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span> <span class="token operator">+</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> padding <span class="token operator">===</span> <span class="token string">&quot;string&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> padding <span class="token operator">+</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Expected string or number, got '</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>padding<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">'.`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">padLeft</span><span class="token punctuation">(</span><span class="token string">&quot;Hello world&quot;</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns &quot;    Hello world&quot;</span>
</code></pre></div><p>padLeft存在一个问题， padding参数的类型指定成了 any。 这就是说我们可以传入一个既不是 number也不是 string类型的参数，但是TypeScript却不报错。</p> <p><code>let indentedString = padLeft(&quot;Hello world&quot;, true); // 编译阶段通过，运行时报错</code></p> <p>在传统的面向对象语言里，我们可能会将这两种类型抽象成有层级的类型。
这么做显然是非常清晰的，但同时也存在了过度设计。
padLeft原始版本的好处之一是允许我们传入原始类型。 这样做的话使用起来既简单又方便。 如果我们就是想使用已经存在的函数的话，这种新的方式就不适用了。
代替 any， 我们可以使用 联合类型做为 padding的参数：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br></div><pre class="language-js"><code><span class="token comment">/**
 * Takes a string and adds &quot;padding&quot; to the left.
 * If 'padding' is a string, then 'padding' is appended to the left side.
 * If 'padding' is a number, then that number of spaces is added to the left side.
 */</span>
<span class="token keyword">function</span> <span class="token function">padLeft</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">:</span> string<span class="token punctuation">,</span> padding<span class="token punctuation">:</span> string <span class="token operator">|</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> indentedString <span class="token operator">=</span> <span class="token function">padLeft</span><span class="token punctuation">(</span><span class="token string">&quot;Hello world&quot;</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// errors during compilation</span>
</code></pre></div><p>联合类型表示一个值可以是几种类型之一。
我们用竖线（ |）分隔每个类型，所以 <code>number | string | boolean</code>表示一个值可以是 <code>number</code>， <code>string</code>，或<code>boolean</code>。</p> <p>如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">Bird</span> <span class="token punctuation">{</span>
    <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">layEggs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Fish</span> <span class="token punctuation">{</span>
    <span class="token function">swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">layEggs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">getSmallPet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Fish <span class="token operator">|</span> Bird <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> pet <span class="token operator">=</span> <span class="token function">getSmallPet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pet<span class="token punctuation">.</span><span class="token function">layEggs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// okay</span>
pet<span class="token punctuation">.</span><span class="token function">swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// errors</span>
</code></pre></div><p>这里的联合类型可能有点复杂，但是你很容易就习惯了。 如果一个值的类型是 A | B，我们能够 确定的是它包含了 A 和 B中共有的成员。 这个例子里， Bird具有一个 fly成员。 我们不能确定一个 Bird | Fish类型的变量是否有 fly方法。 如果变量在运行时是 Fish类型，那么调用 pet.fly()就出错了。</p> <h3 id="类型保护与区分类型（type-guards-and-differentiating-types）">类型保护与区分类型（Type Guards and Differentiating Types）</h3> <p>联合类型适合于那些值可以为不同类型的情况。
但当我们想确切地了解是否为 Fish时怎么办？
JavaScript里常用来区分2个可能值的方法是检查成员是否存在。 如之前提及的，我们只能访问联合类型中共同拥有的成员。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> pet <span class="token operator">=</span> <span class="token function">getSmallPet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 每一个成员访问都会报错</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>pet<span class="token punctuation">.</span>swim<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pet<span class="token punctuation">.</span><span class="token function">swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pet<span class="token punctuation">.</span>fly<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pet<span class="token punctuation">.</span><span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>为了让这段代码工作，我们要使用类型断言：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> pet <span class="token operator">=</span> <span class="token function">getSmallPet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>Fish<span class="token operator">&gt;</span>pet<span class="token punctuation">)</span><span class="token punctuation">.</span>swim<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span><span class="token operator">&lt;</span>Fish<span class="token operator">&gt;</span>pet<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span><span class="token operator">&lt;</span>Bird<span class="token operator">&gt;</span>pet<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="用户自定义的类型保护">用户自定义的类型保护</h3> <p>这里可以注意到我们不得不多次使用类型断言。
假若我们一旦检查过类型，就能在之后的每个分支里清楚地知道 pet的类型的话就好了。</p> <p>TypeScript里的 类型保护机制让它成为了现实。
类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。 要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 类型谓词：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">isFish</span><span class="token punctuation">(</span><span class="token parameter">pet<span class="token punctuation">:</span> Fish <span class="token operator">|</span> Bird</span><span class="token punctuation">)</span><span class="token punctuation">:</span> pet is Fish <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>Fish<span class="token operator">&gt;</span>pet<span class="token punctuation">)</span><span class="token punctuation">.</span>swim <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这个例子里， <code>pet is Fish</code>就是类型谓词。 谓词为 parameterName is Type这种形式， parameterName必须是来自于当前函数签名里的一个参数名。</p> <p>每当使用一些变量调用 isFish时，TypeScript会将变量缩减为那个具体的类型，只要这个类型与变量的原始类型是兼容的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 'swim' 和 'fly' 调用都没有问题了</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFish</span><span class="token punctuation">(</span>pet<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pet<span class="token punctuation">.</span><span class="token function">swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token punctuation">{</span>
    pet<span class="token punctuation">.</span><span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">注意</p> <p>TypeScript不仅知道在 if分支里 pet是 Fish类型； 它还清楚在 else分支里，一定 不是 Fish类型，一定是 Bird类型。</p></div> <h3 id="typeof类型保护">typeof类型保护</h3> <p>现在我们回过头来看看怎么使用联合类型书写 padLeft代码。 我们可以像下面这样利用类型断言来写：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">isNumber</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">:</span> any</span><span class="token punctuation">)</span><span class="token punctuation">:</span> x is number <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">&quot;number&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">isString</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">:</span> any</span><span class="token punctuation">)</span><span class="token punctuation">:</span> x is string <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">&quot;string&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">padLeft</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">:</span> string<span class="token punctuation">,</span> padding<span class="token punctuation">:</span> string <span class="token operator">|</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isNumber</span><span class="token punctuation">(</span>padding<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">Array</span><span class="token punctuation">(</span>padding <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span> <span class="token operator">+</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isString</span><span class="token punctuation">(</span>padding<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> padding <span class="token operator">+</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Expected string or number, got '</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>padding<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">'.`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然而，必须要定义一个函数来判断类型是否是原始类型，这太痛苦了。
幸运的是，现在我们不必将 typeof x === &quot;number&quot;抽象成一个函数，因为TypeScript可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">padLeft</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">:</span> string<span class="token punctuation">,</span> padding<span class="token punctuation">:</span> string <span class="token operator">|</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> padding <span class="token operator">===</span> <span class="token string">&quot;number&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">Array</span><span class="token punctuation">(</span>padding <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span> <span class="token operator">+</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> padding <span class="token operator">===</span> <span class="token string">&quot;string&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> padding <span class="token operator">+</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Expected string or number, got '</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>padding<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">'.`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这些<strong>typeof类型保护</strong>只有两种形式能被识别：</p> <ul><li>typeof v === &quot;typename&quot;</li> <li>typeof v !== &quot;typename&quot;</li></ul> <p><strong>&quot;typename&quot;必须是 &quot;number&quot;， &quot;string&quot;， &quot;boolean&quot;或 &quot;symbol&quot;。</strong></p> <p>但是TypeScript并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。</p> <h3 id="instanceof类型保护">instanceof类型保护</h3> <p>instanceof类型保护是通过构造函数来细化类型的一种方式。
比如，我们借鉴一下之前字符串填充的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">Padder</span> <span class="token punctuation">{</span>
    <span class="token function">getPaddingString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> string
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">SpaceRepeatingPadder</span> <span class="token keyword">implements</span> <span class="token class-name">Padder</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">private</span> numSpaces<span class="token punctuation">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token function">getPaddingString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>numSpaces <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">StringPadder</span> <span class="token keyword">implements</span> <span class="token class-name">Padder</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">private</span> value<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token function">getPaddingString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">getRandomPadder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0.5</span> <span class="token operator">?</span>
        <span class="token keyword">new</span> <span class="token class-name">SpaceRepeatingPadder</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>
        <span class="token keyword">new</span> <span class="token class-name">StringPadder</span><span class="token punctuation">(</span><span class="token string">&quot;  &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 类型为SpaceRepeatingPadder | StringPadder</span>
<span class="token keyword">let</span> padder<span class="token punctuation">:</span> Padder <span class="token operator">=</span> <span class="token function">getRandomPadder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>padder <span class="token keyword">instanceof</span> <span class="token class-name">SpaceRepeatingPadder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    padder<span class="token punctuation">;</span> <span class="token comment">// 类型细化为'SpaceRepeatingPadder'</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>padder <span class="token keyword">instanceof</span> <span class="token class-name">StringPadder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    padder<span class="token punctuation">;</span> <span class="token comment">// 类型细化为'StringPadder'</span>
<span class="token punctuation">}</span>
</code></pre></div><p>instanceof的右侧要求是一个构造函数，TypeScript将细化为：此构造函数的 prototype属性的类型，如果它的类型不为 any的话, 构造签名所返回的类型的联合</p> <h3 id="可以为null的类型">可以为null的类型</h3> <p>TypeScript具有两种特殊的类型:</p> <ul><li>null</li> <li>undefined
它们分别具有值<code>null</code>和<code>undefined</code>.</li></ul> <p>默认情况下，类型检查器认为 <code>null</code>与 <code>undefined</code>可以赋值给任何类型。
<code>null</code>与 <code>undefined</code>是所有其它类型的一个有效值。
这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。 null的发明者，Tony Hoare，称它为 价值亿万美金的错误。</p> <p><code>--strictNullChecks</code>标记可以解决此错误：
当你声明一个变量时，它不会自动地包含 null或 undefined。 你可以使用联合类型明确的包含它们：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>
s <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 错误, 'null'不能赋值给'string'</span>
<span class="token keyword">let</span> sn<span class="token punctuation">:</span> string <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">;</span>
sn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 可以</span>

sn <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">// error, 'undefined'不能赋值给'string | null'</span>
</code></pre></div><p>注意，按照JavaScript的语义，TypeScript会把 <code>null</code>和 <code>undefined</code>区别对待。 <code>string</code> | <code>null，</code> <code>string</code> | <code>undefined</code>和 <code>string</code> | <code>undefined</code> | <code>null</code>是不同的类型。</p> <h3 id="可选参数和可选属性">可选参数和可选属性</h3> <p>使用了 <code>--strictNullChecks</code>，可选参数会被自动地加上 <code>| undefined</code>:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">:</span> number<span class="token punctuation">,</span> y<span class="token operator">?</span><span class="token punctuation">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token punctuation">(</span>y <span class="token operator">||</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error, 'null' is not assignable to 'number | undefined'</span>
</code></pre></div><p>可选属性也会有同样的处理：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> number<span class="token punctuation">;</span>
    b<span class="token operator">?</span><span class="token punctuation">:</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">// error, 'undefined' is not assignable to 'number'</span>
c<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">13</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
c<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// error, 'null' is not assignable to 'number | undefined'</span>
</code></pre></div><h3 id="类型保护和类型断言">类型保护和类型断言</h3> <p>由于可以为null的类型是通过联合类型实现，那么你需要使用类型保护来去除 null。 幸运地是这与在JavaScript里写的代码一致：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">sn<span class="token punctuation">:</span> string <span class="token operator">|</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span><span class="token punctuation">:</span> string <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sn <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;default&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sn<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里很明显地去除了 null，你也可以使用短路运算符：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">sn<span class="token punctuation">:</span> string <span class="token operator">|</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span><span class="token punctuation">:</span> string <span class="token punctuation">{</span>
    <span class="token keyword">return</span> sn <span class="token operator">||</span> <span class="token string">&quot;default&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果编译器不能够去除 null或 undefined，你可以使用类型断言手动去除。 语法是添加 !后缀： identifier!从 identifier的类型里去除了 null和 undefined：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">broken</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">:</span> string <span class="token operator">|</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span><span class="token punctuation">:</span> string <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">postfix</span><span class="token punctuation">(</span><span class="token parameter">epithet<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> name<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.  the '</span> <span class="token operator">+</span> epithet<span class="token punctuation">;</span> <span class="token comment">// error, 'name' is possibly null</span>
  <span class="token punctuation">}</span>
  name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">&quot;Bob&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">postfix</span><span class="token punctuation">(</span><span class="token string">&quot;great&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">fixed</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">:</span> string <span class="token operator">|</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span><span class="token punctuation">:</span> string <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">postfix</span><span class="token punctuation">(</span><span class="token parameter">epithet<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> name<span class="token operator">!</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.  the '</span> <span class="token operator">+</span> epithet<span class="token punctuation">;</span> <span class="token comment">// ok</span>
  <span class="token punctuation">}</span>
  name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">&quot;Bob&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">postfix</span><span class="token punctuation">(</span><span class="token string">&quot;great&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>本例使用了嵌套函数，因为编译器无法去除嵌套函数的null（除非是立即调用的函数表达式）。 因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数做为外层函数的返回值。 如果无法知道函数在哪里被调用，就无法知道调用时 name的类型。</p> <h3 id="类型别名">类型别名</h3> <p>类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。</p> <div class="language-js extra-class"><pre class="language-js"><code>type Name <span class="token operator">=</span> string<span class="token punctuation">;</span>
type <span class="token function-variable function">NameResolver</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> string<span class="token punctuation">;</span>
type NameOrResolver <span class="token operator">=</span> Name <span class="token operator">|</span> NameResolver<span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token parameter">n<span class="token punctuation">:</span> NameOrResolver</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Name <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> n <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">n</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>起别名不会新建一个类型 - 它创建了一个新 名字来引用那个类型。 给原始类型起别名通常没什么用，尽管可以做为文档的一种形式使用。</p> <p>同接口一样，类型别名也可以是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入：</p> <div class="language-js extra-class"><pre class="language-js"><code>type Container<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span> value<span class="token punctuation">:</span> <span class="token constant">T</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>我们也可以使用类型别名来在属性里引用自己：</p> <div class="language-js extra-class"><pre class="language-js"><code>type Tree<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    value<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
    left<span class="token punctuation">:</span> Tree<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
    right<span class="token punctuation">:</span> Tree<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>与交叉类型一起使用，我们可以创建出一些十分稀奇古怪的类型。</p> <div class="language-js extra-class"><pre class="language-js"><code>type LinkedList<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token operator">&amp;</span> <span class="token punctuation">{</span> next<span class="token punctuation">:</span> LinkedList<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> people<span class="token punctuation">:</span> LinkedList<span class="token operator">&lt;</span>Person<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> s <span class="token operator">=</span> people<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token keyword">var</span> s <span class="token operator">=</span> people<span class="token punctuation">.</span>next<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token keyword">var</span> s <span class="token operator">=</span> people<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token keyword">var</span> s <span class="token operator">=</span> people<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
</code></pre></div><p>然而，类型别名不能出现在声明右侧的任何地方。</p> <div class="language-js extra-class"><pre class="language-js"><code>type Yikes <span class="token operator">=</span> Array<span class="token operator">&lt;</span>Yikes<span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// error</span>
</code></pre></div><h3 id="接口-vs-类型别名">接口 vs. 类型别名</h3> <p>像我们提到的，类型别名可以像接口一样；然而，仍有一些细微差别。</p> <ul><li>接口创建了一个新的名字，可以在其它任何地方使用。</li> <li>类型别名并不创建新名字—比如，错误信息就不会使用别名。</li></ul> <p>在下面的示例代码里，在编译器中将鼠标悬停在 interfaced上，显示它返回的是 Interface，但悬停在 aliased上时，显示的却是对象字面量类型。</p> <div class="language-js extra-class"><pre class="language-js"><code>type Alias <span class="token operator">=</span> <span class="token punctuation">{</span> num<span class="token punctuation">:</span> number <span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">Interface</span> <span class="token punctuation">{</span>
    num<span class="token punctuation">:</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
declare <span class="token keyword">function</span> <span class="token function">aliased</span><span class="token punctuation">(</span><span class="token parameter">arg<span class="token punctuation">:</span> Alias</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Alias<span class="token punctuation">;</span>
declare <span class="token keyword">function</span> <span class="token function">interfaced</span><span class="token punctuation">(</span><span class="token parameter">arg<span class="token punctuation">:</span> Interface</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Interface<span class="token punctuation">;</span>
</code></pre></div><p>另一个重要区别是类型别名不能被 <code>extends</code>和 <code>implements</code>（自己也不能 extends和 implements其它类型）。
因为 软件中的对象应该对于扩展是开放的，但是对于修改是封闭的，你应该尽量去使用接口代替类型别名。</p> <p>另一方面，如果你无法通过接口来描述一个类型并且需要使用联合类型或元组类型，这时通常会使用类型别名。</p> <h3 id="字符串字面量类型">字符串字面量类型</h3> <p>字符串字面量类型允许你指定字符串必须的固定值。
在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。
通过结合使用这些特性，你可以实现类似枚举类型的字符串。</p> <div class="language-js extra-class"><pre class="language-js"><code>type Easing <span class="token operator">=</span> <span class="token string">&quot;ease-in&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;ease-out&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;ease-in-out&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">UIElement</span> <span class="token punctuation">{</span>
    <span class="token function">animate</span><span class="token punctuation">(</span><span class="token parameter">dx<span class="token punctuation">:</span> number<span class="token punctuation">,</span> dy<span class="token punctuation">:</span> number<span class="token punctuation">,</span> easing<span class="token punctuation">:</span> Easing</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>easing <span class="token operator">===</span> <span class="token string">&quot;ease-in&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// ...</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>easing <span class="token operator">===</span> <span class="token string">&quot;ease-out&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>easing <span class="token operator">===</span> <span class="token string">&quot;ease-in-out&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// error! should not pass null or undefined.</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> button <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UIElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
button<span class="token punctuation">.</span><span class="token function">animate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&quot;ease-in&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
button<span class="token punctuation">.</span><span class="token function">animate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&quot;uneasy&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error: &quot;uneasy&quot; is not allowed here</span>
</code></pre></div><p>你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。</p> <div class="language- extra-class"><pre class="language-text"><code>Argument of type '&quot;uneasy&quot;' is not assignable to parameter of type '&quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;'
</code></pre></div><p>字符串字面量类型还可以用于区分函数重载：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createElement</span><span class="token punctuation">(</span>tagName<span class="token punctuation">:</span> <span class="token string">&quot;img&quot;</span><span class="token punctuation">)</span><span class="token punctuation">:</span> HTMLImageElement<span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">createElement</span><span class="token punctuation">(</span>tagName<span class="token punctuation">:</span> <span class="token string">&quot;input&quot;</span><span class="token punctuation">)</span><span class="token punctuation">:</span> HTMLInputElement<span class="token punctuation">;</span>
<span class="token comment">// ... more overloads ...</span>
<span class="token keyword">function</span> <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">tagName<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Element <span class="token punctuation">{</span>
    <span class="token comment">// ... code goes here ...</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="数字字面量类型">数字字面量类型</h3> <p>TypeScript还具有数字字面量类型。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">rollDie</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> <span class="token number">4</span> <span class="token operator">|</span> <span class="token number">5</span> <span class="token operator">|</span> <span class="token number">6</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们很少直接这样使用，但它们可以用在缩小范围调试bug的时候：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!==</span> <span class="token number">1</span> <span class="token operator">||</span> x <span class="token operator">!==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//         ~~~~~~~</span>
        <span class="token comment">// Operator '!==' cannot be applied to types '1' and '2'.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>换句话说，当 <code>x</code>与 <code>2</code>进行比较的时候，它的值必须为 <code>1</code>，这就意味着上面的比较检查是非法的。</p> <h3 id="枚举成员类型">枚举成员类型</h3> <p>如我们在 枚举一节里提到的，当每个枚举成员都是用字面量初始化的时候枚举成员是具有类型的。</p> <p>在我们谈及“单例类型”的时候，多数是指枚举成员类型和数字/字符串字面量类型，尽管大多数用户会互换使用“单例类型”和“字面量类型”。</p> <h3 id="可辨识联合（discriminated-unions）">可辨识联合（Discriminated Unions）</h3> <p>你可以合并单例类型，联合类型，类型保护和类型别名来创建一个叫做 可辨识联合的高级模式，它也称做 标签联合或 代数数据类型。 可辨识联合在函数式编程很有用处。 一些语言会自动地为你辨识联合；而TypeScript则基于已有的JavaScript模式。 它具有3个要素：</p> <p>具有普通的单例类型属性— 可辨识的特征。
一个类型别名包含了那些类型的联合— 联合。
此属性上的类型保护。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">Square</span> <span class="token punctuation">{</span>
    kind<span class="token punctuation">:</span> <span class="token string">&quot;square&quot;</span><span class="token punctuation">;</span>
    size<span class="token punctuation">:</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
    kind<span class="token punctuation">:</span> <span class="token string">&quot;rectangle&quot;</span><span class="token punctuation">;</span>
    width<span class="token punctuation">:</span> number<span class="token punctuation">;</span>
    height<span class="token punctuation">:</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">Circle</span> <span class="token punctuation">{</span>
    kind<span class="token punctuation">:</span> <span class="token string">&quot;circle&quot;</span><span class="token punctuation">;</span>
    radius<span class="token punctuation">:</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>首先我们声明了将要联合的接口。 每个接口都有 kind属性但有不同的字符串字面量类型。 kind属性称做 可辨识的特征或 标签。 其它的属性则特定于各个接口。 注意，目前各个接口间是没有联系的。 下面我们把它们联合到一起：</p> <div class="language-js extra-class"><pre class="language-js"><code>type Shape <span class="token operator">=</span> Square <span class="token operator">|</span> Rectangle <span class="token operator">|</span> Circle<span class="token punctuation">;</span>
</code></pre></div><p>现在我们使用可辨识联合:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token parameter">s<span class="token punctuation">:</span> Shape</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>kind<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token string">&quot;square&quot;</span><span class="token punctuation">:</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span>size <span class="token operator">*</span> s<span class="token punctuation">.</span>size<span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">&quot;rectangle&quot;</span><span class="token punctuation">:</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span>height <span class="token operator">*</span> s<span class="token punctuation">.</span>width<span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">&quot;circle&quot;</span><span class="token punctuation">:</span> <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token constant">PI</span> <span class="token operator">*</span> s<span class="token punctuation">.</span>radius <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="完整性检查">完整性检查</h3> <p>当没有涵盖所有可辨识联合的变化时，我们想让编译器可以通知我们。 比如，如果我们添加了 Triangle到 Shape，我们同时还需要更新 area:</p> <div class="language-js extra-class"><pre class="language-js"><code>type Shape <span class="token operator">=</span> Square <span class="token operator">|</span> Rectangle <span class="token operator">|</span> Circle <span class="token operator">|</span> Triangle<span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token parameter">s<span class="token punctuation">:</span> Shape</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>kind<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token string">&quot;square&quot;</span><span class="token punctuation">:</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span>size <span class="token operator">*</span> s<span class="token punctuation">.</span>size<span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">&quot;rectangle&quot;</span><span class="token punctuation">:</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span>height <span class="token operator">*</span> s<span class="token punctuation">.</span>width<span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">&quot;circle&quot;</span><span class="token punctuation">:</span> <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token constant">PI</span> <span class="token operator">*</span> s<span class="token punctuation">.</span>radius <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// should error here - we didn't handle case &quot;triangle&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>有两种方式可以实现。 首先是启用 --strictNullChecks并且指定一个返回值类型：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token parameter">s<span class="token punctuation">:</span> Shape</span><span class="token punctuation">)</span><span class="token punctuation">:</span> number <span class="token punctuation">{</span> <span class="token comment">// error: returns number | undefined</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>kind<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token string">&quot;square&quot;</span><span class="token punctuation">:</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span>size <span class="token operator">*</span> s<span class="token punctuation">.</span>size<span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">&quot;rectangle&quot;</span><span class="token punctuation">:</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span>height <span class="token operator">*</span> s<span class="token punctuation">.</span>width<span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">&quot;circle&quot;</span><span class="token punctuation">:</span> <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token constant">PI</span> <span class="token operator">*</span> s<span class="token punctuation">.</span>radius <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>因为 switch没有包涵所有情况，所以TypeScript认为这个函数有时候会返回 undefined。 如果你明确地指定了返回值类型为 number，那么你会看到一个错误，因为实际上返回值的类型为 number | undefined。 然而，这种方法存在些微妙之处且 --strictNullChecks对旧代码支持不好。</p> <p>第二种方法使用 never类型，编译器用它来进行完整性检查：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">assertNever</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">:</span> never</span><span class="token punctuation">)</span><span class="token punctuation">:</span> never <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Unexpected object: &quot;</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token parameter">s<span class="token punctuation">:</span> Shape</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>kind<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token string">&quot;square&quot;</span><span class="token punctuation">:</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span>size <span class="token operator">*</span> s<span class="token punctuation">.</span>size<span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">&quot;rectangle&quot;</span><span class="token punctuation">:</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span>height <span class="token operator">*</span> s<span class="token punctuation">.</span>width<span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">&quot;circle&quot;</span><span class="token punctuation">:</span> <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token constant">PI</span> <span class="token operator">*</span> s<span class="token punctuation">.</span>radius <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token function">assertNever</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error here if there are missing cases</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里， assertNever检查 s是否为 never类型—即为除去所有可能情况后剩下的类型。 如果你忘记了某个case，那么 s将具有一个真实的类型并且你会得到一个错误。 这种方式需要你定义一个额外的函数，但是在你忘记某个case的时候也更加明显。</p> <h3 id="多态的-this类型">多态的 this类型</h3> <p>多态的 this类型表示的是某个包含类或接口的 子类型。 这被称做 F-bounded多态性。 它能很容易的表现连贯接口间的继承.
比如。 在计算器的例子里，在每个操作之后都返回 this类型：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">BasicCalculator</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">protected</span> value<span class="token punctuation">:</span> number <span class="token operator">=</span> <span class="token number">0</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token function">currentValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> number <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token function">add</span><span class="token punctuation">(</span>operand<span class="token punctuation">:</span> number<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">this</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">+=</span> operand<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token function">multiply</span><span class="token punctuation">(</span>operand<span class="token punctuation">:</span> number<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">this</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">*=</span> operand<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// ... other operations go here ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BasicCalculator</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">multiply</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">currentValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>由于这个类使用了 this类型，你可以继承它，新的类可以直接使用之前的方法，不需要做任何的改变。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">ScientificCalculator</span> <span class="token keyword">extends</span> <span class="token class-name">BasicCalculator</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">value <span class="token operator">=</span> <span class="token number">0</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token function">sin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// ... other operations go here ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScientificCalculator</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">multiply</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">currentValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果没有 this类型， ScientificCalculator就不能够在继承 BasicCalculator的同时还保持接口的连贯性。
multiply将会返回 BasicCalculator，它并没有 sin方法。
然而，使用 this类型， multiply会返回 this，在这里就是 ScientificCalculator。</p> <h3 id="索引类型（index-types）">索引类型（Index types）</h3> <p>使用索引类型，编译器就能够检查使用了动态属性名的代码。 例如，一个常见的JavaScript模式是从对象中选取属性的子集。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">pluck</span><span class="token punctuation">(</span><span class="token parameter">o<span class="token punctuation">,</span> names</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> names<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">n</span> <span class="token operator">=&gt;</span> o<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>下面是如何在TypeScript里使用此函数，通过 索引类型查询和 索引访问操作符：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> pluck<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token class-name">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>o<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> names<span class="token punctuation">:</span> <span class="token constant">K</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> names<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">n</span> <span class="token operator">=&gt;</span> o<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
    age<span class="token punctuation">:</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> person<span class="token punctuation">:</span> Person <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> <span class="token string">'Jarid'</span><span class="token punctuation">,</span>
    age<span class="token punctuation">:</span> <span class="token number">35</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> strings<span class="token punctuation">:</span> string<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">pluck</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok, string[]</span>
</code></pre></div><p>编译器会检查 name是否真的是 Person的一个属性。 本例还引入了几个新的类型操作符。 首先是 keyof T， 索引类型查询操作符。 对于任何类型 T， keyof T的结果为 T上已知的公共属性名的联合。 例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> personProps<span class="token punctuation">:</span> keyof Person<span class="token punctuation">;</span> <span class="token comment">// 'name' | 'age'</span>
</code></pre></div><p>keyof Person是完全可以与 'name' | 'age'互相替换的。 不同的是如果你添加了其它的属性到 Person，例如 address: string，那么 keyof Person会自动变为 'name' | 'age' | 'address'。 你可以在像 pluck函数这类上下文里使用 keyof，因为在使用之前你并不清楚可能出现的属性名。 但编译器会检查你是否传入了正确的属性名给 pluck：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">pluck</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'age'</span><span class="token punctuation">,</span> <span class="token string">'unknown'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error, 'unknown' is not in 'name' | 'age'</span>
</code></pre></div><p>第二个操作符是 T[K]， 索引访问操作符。 在这里，类型语法反映了表达式语法。 这意味着 person['name']具有类型 Person['name'] — 在我们的例子里则为 string类型。 然而，就像索引类型查询一样，你可以在普通的上下文里使用 T[K]，这正是它的强大所在。 你只要确保类型变量 K extends keyof T就可以了。 例如下面 getProperty函数的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> getProperty<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token class-name">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>o<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token constant">K</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> o<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// o[name] is of type T[K]</span>
<span class="token punctuation">}</span>
getProperty里的 o<span class="token punctuation">:</span> <span class="token constant">T</span>和 name<span class="token punctuation">:</span> <span class="token constant">K</span>，意味着 o<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span>。 当你返回 <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span>的结果，编译器会实例化键的真实类型，因此 getProperty的返回值类型会随着你需要的属性改变。

<span class="token keyword">let</span> name<span class="token punctuation">:</span> string <span class="token operator">=</span> <span class="token function">getProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> age<span class="token punctuation">:</span> number <span class="token operator">=</span> <span class="token function">getProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">'age'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> unknown <span class="token operator">=</span> <span class="token function">getProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">'unknown'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error, 'unknown' is not in 'name' | 'age'</span>
</code></pre></div><h3 id="索引类型和字符串索引签名">索引类型和字符串索引签名</h3> <p>keyof和 T[K]与字符串索引签名进行交互。 如果你有一个带有字符串索引签名的类型，那么 keyof T会是 string。 并且 T[string]为索引签名的类型：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">Map</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>key<span class="token punctuation">:</span> string<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> keys<span class="token punctuation">:</span> keyof Map<span class="token operator">&lt;</span>number<span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">let</span> value<span class="token punctuation">:</span> Map<span class="token operator">&lt;</span>number<span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token string">'foo'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// number</span>
</code></pre></div><h3 id="映射类型">映射类型</h3> <p>一个常见的任务是将一个已知的类型每个属性都变为可选的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">PersonPartial</span> <span class="token punctuation">{</span>
    name<span class="token operator">?</span><span class="token punctuation">:</span> string<span class="token punctuation">;</span>
    age<span class="token operator">?</span><span class="token punctuation">:</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>或者我们想要一个只读版本：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">PersonReadonly</span> <span class="token punctuation">{</span>
    readonly name<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
    readonly age<span class="token punctuation">:</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这在JavaScript里经常出现，TypeScript提供了从旧类型中创建新类型的一种方式 — 映射类型。 在映射类型里，新类型以相同的形式去转换旧类型里每个属性。
例如，你可以令每个属性成为 readonly类型或可选的。 下面是一些例子：</p> <div class="language-js extra-class"><pre class="language-js"><code>type Readonly<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    readonly <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> keyof <span class="token constant">T</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
type Partial<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> keyof <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>像下面这样使用：</p> <div class="language-js extra-class"><pre class="language-js"><code>type PersonPartial <span class="token operator">=</span> Partial<span class="token operator">&lt;</span>Person<span class="token operator">&gt;</span><span class="token punctuation">;</span>
type ReadonlyPerson <span class="token operator">=</span> Readonly<span class="token operator">&lt;</span>Person<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div><p>下面来看看最简单的映射类型和它的组成部分：</p> <div class="language-js extra-class"><pre class="language-js"><code>type Keys <span class="token operator">=</span> <span class="token string">'option1'</span> <span class="token operator">|</span> <span class="token string">'option2'</span><span class="token punctuation">;</span>
type Flags <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> Keys<span class="token punctuation">]</span><span class="token punctuation">:</span> boolean <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>它的语法与索引签名的语法类型，内部使用了 <code>for .. in</code>。 具有三个部分：</p> <p>类型变量 K，它会依次绑定到每个属性。
字符串字面量联合的 Keys，它包含了要迭代的属性名的集合。
属性的结果类型。
在这个简单的例子里， Keys是硬编码的的属性名列表并且属性类型永远是 boolean，因此这个映射类型等同于：</p> <div class="language-js extra-class"><pre class="language-js"><code>type Flags <span class="token operator">=</span> <span class="token punctuation">{</span>
    option1<span class="token punctuation">:</span> boolean<span class="token punctuation">;</span>
    option2<span class="token punctuation">:</span> boolean<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在真正的应用里，可能不同于上面的 Readonly或 Partial。 它们会基于一些已存在的类型，且按照一定的方式转换字段。 这就是 keyof和索引访问类型要做的事情：</p> <div class="language-js extra-class"><pre class="language-js"><code>type NullablePerson <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> keyof Person<span class="token punctuation">]</span><span class="token punctuation">:</span> Person<span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">}</span>
type PartialPerson <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> keyof Person<span class="token punctuation">]</span><span class="token operator">?</span><span class="token punctuation">:</span> Person<span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>
</code></pre></div><p>但它更有用的地方是可以有一些通用版本。</p> <div class="language-js extra-class"><pre class="language-js"><code>type Nullable<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> keyof <span class="token constant">T</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">}</span>
type Partial<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> keyof <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>
</code></pre></div><p>在这些例子里，属性列表是 keyof T且结果类型是 T[P]的变体。
这是使用通用映射类型的一个好模版。 因为这类转换是 同态的，映射只作用于 T的属性而没有其它的。
编译器知道在添加任何新属性之前可以拷贝所有存在的属性修饰符。 例如，假设 Person.name是只读的，那么 <code>Partial&lt;Person&gt;.name</code>也将是只读的且为可选的。</p> <p>下面是另一个例子， T[P]被包装在 <code>Proxy&lt;T&gt;</code>类里：</p> <div class="language-js extra-class"><pre class="language-js"><code>type Proxy<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
    <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
type Proxify<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> keyof <span class="token constant">T</span><span class="token punctuation">]</span><span class="token punctuation">:</span> Proxy<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> proxify<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>o<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Proxify<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
   <span class="token comment">// ... wrap proxies ...</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> proxyProps <span class="token operator">=</span> <span class="token function">proxify</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>注意 <code>Readonly&lt;T&gt;</code>和 <code>Partial&lt;T&gt;</code>用处不小，因此它们与 Pick和 Record一同被包含进了TypeScript的标准库里：</p> <div class="language-js extra-class"><pre class="language-js"><code>type Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token class-name">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
type Record<span class="token operator">&lt;</span><span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token class-name">string</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Readonly， Partial和 Pick是同态的，但 Record不是。 因为 Record并不需要输入类型来拷贝属性，所以它不属于同态：</p> <div class="language-js extra-class"><pre class="language-js"><code>type ThreeStringProps <span class="token operator">=</span> Record<span class="token operator">&lt;</span><span class="token string">'prop1'</span> <span class="token operator">|</span> <span class="token string">'prop2'</span> <span class="token operator">|</span> <span class="token string">'prop3'</span><span class="token punctuation">,</span> string<span class="token operator">&gt;</span>
</code></pre></div><p>非同态类型本质上会创建新的属性，因此它们不会从它处拷贝属性修饰符。</p> <h3 id="由映射类型进行推断">由映射类型进行推断</h3> <p>现在你了解了如何包装一个类型的属性，那么接下来就是如何拆包。 其实这也非常容易：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> unproxify<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>t<span class="token punctuation">:</span> Proxify<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">as</span> <span class="token constant">T</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> k <span class="token keyword">in</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        result<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> originalProps <span class="token operator">=</span> <span class="token function">unproxify</span><span class="token punctuation">(</span>proxyProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>注意这个拆包推断只适用于同态的映射类型。 如果映射类型不是同态的，那么需要给拆包函数一个明确的类型参数。</p> <h3 id="预定义的有条件类型">预定义的有条件类型</h3> <p>TypeScript 2.8在lib.d.ts里增加了一些预定义的有条件类型：</p> <div class="language- extra-class"><pre class="language-text"><code>Exclude&lt;T, U&gt; -- 从T中剔除可以赋值给U的类型。
Extract&lt;T, U&gt; -- 提取T中可以赋值给U的类型。
NonNullable&lt;T&gt; -- 从T中剔除null和undefined。
ReturnType&lt;T&gt; -- 获取函数返回值类型。
InstanceType&lt;T&gt; -- 获取构造函数类型的实例类型。
</code></pre></div><p>示例</p> <div class="language-js extra-class"><pre class="language-js"><code>type <span class="token constant">T00</span> <span class="token operator">=</span> Exclude<span class="token operator">&lt;</span><span class="token string">&quot;a&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;b&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;c&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;d&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;a&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;c&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;f&quot;</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// &quot;b&quot; | &quot;d&quot;</span>
type <span class="token constant">T01</span> <span class="token operator">=</span> Extract<span class="token operator">&lt;</span><span class="token string">&quot;a&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;b&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;c&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;d&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;a&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;c&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;f&quot;</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// &quot;a&quot; | &quot;c&quot;</span>

type <span class="token constant">T02</span> <span class="token operator">=</span> Exclude<span class="token operator">&lt;</span>string <span class="token operator">|</span> number <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Function<span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// string | number</span>
type <span class="token constant">T03</span> <span class="token operator">=</span> Extract<span class="token operator">&lt;</span>string <span class="token operator">|</span> number <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Function<span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// () =&gt; void</span>

type <span class="token constant">T04</span> <span class="token operator">=</span> NonNullable<span class="token operator">&lt;</span>string <span class="token operator">|</span> number <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// string | number</span>
type <span class="token constant">T05</span> <span class="token operator">=</span> NonNullable<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> string<span class="token punctuation">)</span> <span class="token operator">|</span> string<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// (() =&gt; string) | string[]</span>

<span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token parameter">s<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> s <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
    x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

type <span class="token constant">T10</span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> string<span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// string</span>
type <span class="token constant">T11</span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token parameter">s<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// void</span>
type <span class="token constant">T12</span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// {}</span>
type <span class="token constant">T13</span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">U</span><span class="token punctuation">,</span> <span class="token constant">U</span> <span class="token keyword">extends</span> <span class="token class-name">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// number[]</span>
type <span class="token constant">T14</span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token keyword">typeof</span> f1<span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// { a: number, b: string }</span>
type <span class="token constant">T15</span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// any</span>
type <span class="token constant">T16</span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span>never<span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// any</span>
type <span class="token constant">T17</span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// Error</span>
type <span class="token constant">T18</span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span>Function<span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// Error</span>

type <span class="token constant">T20</span> <span class="token operator">=</span> InstanceType<span class="token operator">&lt;</span><span class="token keyword">typeof</span> <span class="token constant">C</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// C</span>
type <span class="token constant">T21</span> <span class="token operator">=</span> InstanceType<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// any</span>
type <span class="token constant">T22</span> <span class="token operator">=</span> InstanceType<span class="token operator">&lt;</span>never<span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// any</span>
type <span class="token constant">T23</span> <span class="token operator">=</span> InstanceType<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// Error</span>
type <span class="token constant">T24</span> <span class="token operator">=</span> InstanceType<span class="token operator">&lt;</span>Function<span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// Error</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">注意</p> <p>Exclude类型是建议的Diff类型的一种实现。我们使用Exclude这个名字是为了避免破坏已经定义了Diff的代码，并且我们感觉这个名字能更好地表达类型的语义。我们没有增加Omit&lt;T, K&gt;类型，因为它可以很容易的用Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;来表示。</p></div> <h2 id="变量声明">变量声明</h2> <p><code>let</code>和<code>const</code>是<code>JavaScript</code>里相对较新的变量声明方式。</p> <ul><li>let在很多方面与var是相似的，但是可以帮助大家避免在JavaScript里常见一些问题。</li> <li>const是对let的一个增强，它能阻止对一个变量再次赋值。</li></ul> <p>因为TypeScript是JavaScript的超集，所以它本身就支持<code>let</code>和<code>const</code>。
下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替<code>var</code>。</p> <h3 id="var声明"><code>var</code>声明</h3> <p>通常我们都是通过<code>var</code>关键字定义JavaScript变量。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre></div><p>很简单, 这里定义了一个名为a值为10的变量。</p> <p>当然, 我们也可以函数内部定义变量：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> message <span class="token operator">=</span> <span class="token string">&quot;Hello, world!&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> message<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>也可以在其它函数内部访问相同的变量。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> h <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">h</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns 11;</span>
</code></pre></div><p>上面的例子里，g可以获取到f函数里定义的a变量。 每当 h被调用时，它都可以访问到f里的a变量。 此时就形成了闭包, 变量h可以随时访问和修改变量a</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> b<span class="token punctuation">;</span>

    <span class="token keyword">function</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns 2</span>
</code></pre></div><h4 id="作用域规则">作用域规则</h4> <p>对于熟悉其它语言的人来说，var声明有些奇怪的作用域规则。 看下面的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">shouldInitialize<span class="token punctuation">:</span> boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>shouldInitialize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// returns '10'</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns 'undefined'</span>
</code></pre></div><p>变量<code>x</code>是定义在<code>if</code>语句里面的，但是我们却可以在语句的外面访问它。
这是因为<code>var</code>声明可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问（我们后面会详细介绍），包含它的代码块对此没有什么影响。 有些人称此为<strong>var作用域或函数作用域</strong>。 函数参数也使用函数作用域。</p> <p>这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">sumMatrix</span><span class="token punctuation">(</span><span class="token parameter">matrix<span class="token punctuation">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> currentRow <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> currentRow<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sum <span class="token operator">+=</span> currentRow<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里很容易看出一些问题，里层的for循环会覆盖变量i，因为所有i都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。</p> <h4 id="捕获变量怪异之处">捕获变量怪异之处</h4> <p>快速的猜一下下面的代码会返回什么：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token operator">*</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>好吧，看一下结果：</p> <div class="language- extra-class"><pre class="language-text"><code>10
10
10
10
10
10
10
10
10
10
</code></pre></div><p>很多JavaScript程序员对这种行为已经很熟悉了，但如果你很不解，你并不是一个人。 大多数人期望输出结果是这样：</p> <div class="language- extra-class"><pre class="language-text"><code>0
1
2
3
4
5
6
7
8
9
</code></pre></div><p>还记得我们上面提到的捕获变量吗？</p> <blockquote><p>我们传给setTimeout的每一个函数表达式实际上都引用了相同作用域里的同一个i。</p></blockquote> <p>让我们花点时间思考一下这是为什么。 setTimeout在若干毫秒后执行一个函数，并且是在for循环结束后。 for循环结束后，i的值为10。 所以当函数被调用的时候，它会打印出 10！</p> <p>一个通常的解决方法是使用立即执行的函数表达式（<code>IIFE</code>）来捕获每次迭代时i的值：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// capture the current state of 'i'</span>
    <span class="token comment">// by invoking a function with its current value</span>
    <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token operator">*</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这种奇怪的形式我们已经司空见惯了。 参数 i会覆盖for循环里的i，但是因为我们起了同样的名字，所以我们不用怎么改for循环体里的代码。</p> <h3 id="let-声明">let 声明</h3> <p>现在你已经知道了<code>var</code>存在一些问题，这恰好说明了为什么用<code>let</code>语句来声明变量。 除了名字不同外， <code>let</code>与<code>var</code>的写法一致。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> hello <span class="token operator">=</span> <span class="token string">&quot;Hello!&quot;</span><span class="token punctuation">;</span>
</code></pre></div><p>主要的区别不在语法上，而是语义，我们接下来会深入研究。</p> <h4 id="块作用域">块作用域</h4> <div class="tip custom-block"><p>当用let声明一个变量，它使用的是词法作用域或块作用域。
不同于使用 var声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或for循环之外是不能访问的。</p></div> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">input<span class="token punctuation">:</span> boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Still okay to reference 'a'</span>
        <span class="token keyword">let</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Error: 'b' doesn't exist here</span>
    <span class="token keyword">return</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里我们定义了2个变量a和b。 a的作用域是f函数体内，而b的作用域是if语句块里。</p> <p>在catch语句里声明的变量也具有同样的作用域规则。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token string">&quot;oh no!&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Oh well.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Error: 'e' doesn't exist here</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>拥有块级作用域的变量的另一个特点是: <strong>它们不能在被声明之前读或写</strong>。</p> <p>虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于 暂时性死区。 它只是用来说明我们不能在 let语句之前访问它们，幸运的是TypeScript可以告诉我们这些信息。</p> <div class="language-js extra-class"><pre class="language-js"><code>a<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// illegal to use 'a' before it's declared;</span>
<span class="token keyword">let</span> a<span class="token punctuation">;</span>
</code></pre></div><p>注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为ES2015，现代的运行时会抛出一个错误；然而，现今TypeScript是不会报错的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// okay to capture 'a'</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 不能在'a'被声明前调用'foo'</span>
<span class="token comment">// 运行时应该抛出错误</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> a<span class="token punctuation">;</span>
</code></pre></div><p>关于暂时性死区的更多信息，查看这里<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let" target="_blank" rel="noopener noreferrer">Mozilla Developer Network<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>.</p> <h4 id="重定义及屏蔽">重定义及屏蔽</h4> <p>我们提过使用var声明时，它不在乎你声明多少次；你只会得到1个。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x<span class="token punctuation">;</span>
    <span class="token keyword">var</span> x<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在上面的例子里，所有x的声明实际上都引用一个相同的x，并且这是完全有效的代码。 这经常会成为bug的来源。 好的是， let声明就不会这么宽松了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">// 错误，不能在1个作用域里多次声明`x`</span>
</code></pre></div><div class="tip custom-block"><p>并不是要求两个均是块级作用域的声明TypeScript才会给出一个错误的警告。</p></div> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// error: interferes with parameter declaration</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// error: can't have both declarations of 'x'</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="tip custom-block"><p>并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。</p></div> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">condition<span class="token punctuation">,</span> x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns 0</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// returns 100</span>
</code></pre></div><p>在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 let重写之前的sumMatrix函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">sumMatrix</span><span class="token punctuation">(</span><span class="token parameter">matrix<span class="token punctuation">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> currentRow <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> currentRow<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sum <span class="token operator">+=</span> currentRow<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个版本的循环能得到正确的结果，因为内层循环的i可以屏蔽掉外层循环的i。</p> <p>通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好打算一下。</p> <h4 id="块级作用域变量的获取">块级作用域变量的获取</h4> <p>在var声明的变量后，每次进入一个作用域时，它创建了一个变量的上下文环境。 就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">theCityThatAlwaysSleeps</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> getCity<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> city <span class="token operator">=</span> <span class="token string">&quot;Seattle&quot;</span><span class="token punctuation">;</span>
        <span class="token function-variable function">getCity</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> city<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token function">getCity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>因为我们已经在city的环境里获取到了city，所以就算if语句执行结束后我们仍然可以访问它。</p> <p>回想一下前面setTimeout的例子，我们最后需要使用立即执行的函数表达式来获取每次for循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在TypeScript里这样做了。</p> <p>当let声明出现在循环体里时拥有完全不同的行为。 不仅是在循环里引入了一个新的变量环境，而是针对 每次迭代都会创建这样一个新作用域。 这就是我们在使用立即执行的函数表达式时做的事，所以在 setTimeout例子里我们仅使用let声明就可以了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token operator">*</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>会输出与预料一致的结果：</p> <div class="language- extra-class"><pre class="language-text"><code>0
1
2
3
4
5
6
7
8
9
</code></pre></div><h3 id="const-声明">const 声明</h3> <p>const 声明是声明变量的另一种方式。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> numLivesForCat <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
</code></pre></div><p>它们与let声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。</p> <div class="tip custom-block"><p>const拥有与 let相同的作用域规则，但是不能对它们重新赋值。</p></div> <p>例如:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> numLivesForCat <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> kitty <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> <span class="token string">&quot;Aurora&quot;</span><span class="token punctuation">,</span>
    numLives<span class="token punctuation">:</span> numLivesForCat<span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token comment">// Error</span>
kitty <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> <span class="token string">&quot;Danielle&quot;</span><span class="token punctuation">,</span>
    numLives<span class="token punctuation">:</span> numLivesForCat
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// all &quot;okay&quot;</span>
kitty<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Rory&quot;</span><span class="token punctuation">;</span>
kitty<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Kitty&quot;</span><span class="token punctuation">;</span>
kitty<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Cat&quot;</span><span class="token punctuation">;</span>
kitty<span class="token punctuation">.</span>numLives<span class="token operator">--</span><span class="token punctuation">;</span>
</code></pre></div><p>除非你使用特殊的方法去避免，实际上const变量的内部状态是可修改的。 幸运的是，TypeScript允许你将对象的成员设置成只读的。 接口一章有详细说明。</p> <h3 id="let-vs-const">let vs. const</h3> <p>现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。 与大多数泛泛的问题一样，答案是：<strong>依情况而定</strong>。</p> <p>使用<strong>最小特权原则</strong>:
所有变量除了你计划去修改的都应该使用const。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。 使用 const也可以让我们更容易的推测数据的流动。</p> <p>跟据你的自己判断，如果合适的话，与团队成员商议一下。</p> <p>这个手册大部分地方都使用了let声明。</p> <h3 id="解构">解构</h3> <h4 id="解构数组">解构数组</h4> <p>最简单的解构莫过于数组的解构赋值了：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> input <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token punctuation">[</span>first<span class="token punctuation">,</span> second<span class="token punctuation">]</span> <span class="token operator">=</span> input<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// outputs 1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// outputs 2</span>
</code></pre></div><p>这创建了2个命名变量 first 和 second。 相当于使用了索引，但更为方便：</p> <div class="language-js extra-class"><pre class="language-js"><code>first <span class="token operator">=</span> input<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
second <span class="token operator">=</span> input<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>解构作用于已声明的变量会更好：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// swap variables</span>
<span class="token punctuation">[</span>first<span class="token punctuation">,</span> second<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>second<span class="token punctuation">,</span> first<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>作用于函数参数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>first<span class="token punctuation">,</span> second<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>number<span class="token punctuation">,</span> number<span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>你可以在数组里使用<code>...</code>语法创建剩余变量：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">[</span>first<span class="token punctuation">,</span> <span class="token operator">...</span>rest<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// outputs 1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>rest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// outputs [ 2, 3, 4 ]</span>
</code></pre></div><p>当然，由于是JavaScript, 你可以忽略你不关心的尾随元素：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">[</span>first<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// outputs 1</span>
</code></pre></div><p>或其它元素：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> second<span class="token punctuation">,</span> <span class="token punctuation">,</span> fourth<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="对象解构">对象解构</h4> <p>你也可以解构对象：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">,</span>
    b<span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">,</span>
    c<span class="token punctuation">:</span> <span class="token string">&quot;bar&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token punctuation">}</span> <span class="token operator">=</span> o<span class="token punctuation">;</span>
</code></pre></div><p>这通过 o.a and o.b 创建了 a 和 b 。 注意，如果你不需要 c 你可以忽略它。</p> <p>就像数组解构，你可以用没有声明的赋值：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token string">&quot;baz&quot;</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">101</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>注意，我们需要用括号将它括起来，因为Javascript通常会将以 { 起始的语句解析为一个块。</p> <p>你可以在对象里使用...语法创建剩余变量：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span> <span class="token operator">...</span>passthrough <span class="token punctuation">}</span> <span class="token operator">=</span> o<span class="token punctuation">;</span>
<span class="token keyword">let</span> total <span class="token operator">=</span> passthrough<span class="token punctuation">.</span>b <span class="token operator">+</span> passthrough<span class="token punctuation">.</span>c<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
</code></pre></div><h4 id="属性重命名">属性重命名</h4> <p>你也可以给属性以不同的名字：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> newName1<span class="token punctuation">,</span> b<span class="token punctuation">:</span> newName2 <span class="token punctuation">}</span> <span class="token operator">=</span> o<span class="token punctuation">;</span>
</code></pre></div><p>这里的语法开始变得混乱。 你可以将 a: newName1 读做 &quot;a 作为 newName1&quot;。 方向是从左到右，好像你写成了以下样子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> newName1 <span class="token operator">=</span> o<span class="token punctuation">.</span>a<span class="token punctuation">;</span>
<span class="token keyword">let</span> newName2 <span class="token operator">=</span> o<span class="token punctuation">.</span>b<span class="token punctuation">;</span>
</code></pre></div><p>令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型， 仍然需要在其后写上完整的模式。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">{</span>a<span class="token punctuation">,</span> b<span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>a<span class="token punctuation">:</span> string<span class="token punctuation">,</span> b<span class="token punctuation">:</span> number<span class="token punctuation">}</span> <span class="token operator">=</span> o<span class="token punctuation">;</span>
</code></pre></div><h4 id="默认值">默认值</h4> <p>默认值可以让你在属性为 undefined 时使用缺省值：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">keepWholeObject</span><span class="token punctuation">(</span><span class="token parameter">wholeObject<span class="token punctuation">:</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> string<span class="token punctuation">,</span> b<span class="token operator">?</span><span class="token punctuation">:</span> number <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1001</span> <span class="token punctuation">}</span> <span class="token operator">=</span> wholeObject<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在，即使 b 为 undefined ， keepWholeObject 函数的变量 wholeObject 的属性 a 和 b 都会有值。</p> <h4 id="函数声明">函数声明</h4> <p>解构也能用于函数声明。 看以下简单的情况：</p> <div class="language-js extra-class"><pre class="language-js"><code>type <span class="token constant">C</span> <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> string<span class="token punctuation">,</span> b<span class="token operator">?</span><span class="token punctuation">:</span> number <span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token constant">C</span></span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">=</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上面的代码是一个类型推断的例子，将在本手册后文介绍。</p> <p>其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token string">&quot;&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token string">&quot;yes&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok, default b = 0</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok, default to {a: &quot;&quot;}, which then defaults b = 0</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error, 'a' is required if you supply an argument</span>
</code></pre></div><p>要小心使用解构。
从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。</p> <div class="tip custom-block"><p>解构表达式要尽量保持小而简单。</p></div> <p>你自己也可以直接使用解构将会生成的赋值表达式。</p> <h4 id="展开">展开</h4> <p>展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> first <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> second <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> bothPlus <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">...</span>first<span class="token punctuation">,</span> <span class="token operator">...</span>second<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>这会令bothPlus的值为[0, 1, 2, 3, 4, 5]。 展开操作创建了 first和second的一份浅拷贝。 它们不会被展开操作所改变。</p> <p>你还可以展开对象：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> defaults <span class="token operator">=</span> <span class="token punctuation">{</span> food<span class="token punctuation">:</span> <span class="token string">&quot;spicy&quot;</span><span class="token punctuation">,</span> price<span class="token punctuation">:</span> <span class="token string">&quot;$$&quot;</span><span class="token punctuation">,</span> ambiance<span class="token punctuation">:</span> <span class="token string">&quot;noisy&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> search <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>defaults<span class="token punctuation">,</span> food<span class="token punctuation">:</span> <span class="token string">&quot;rich&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>search的值为{ food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; }。 对象的展开比数组的展开要复杂的多。 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在展开对象后面的属性会覆盖前面的属性。 因此，如果我们修改上面的例子，在结尾处进行展开的话：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> defaults <span class="token operator">=</span> <span class="token punctuation">{</span> food<span class="token punctuation">:</span> <span class="token string">&quot;spicy&quot;</span><span class="token punctuation">,</span> price<span class="token punctuation">:</span> <span class="token string">&quot;$$&quot;</span><span class="token punctuation">,</span> ambiance<span class="token punctuation">:</span> <span class="token string">&quot;noisy&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> search <span class="token operator">=</span> <span class="token punctuation">{</span> food<span class="token punctuation">:</span> <span class="token string">&quot;rich&quot;</span><span class="token punctuation">,</span> <span class="token operator">...</span>defaults <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>那么，defaults里的food属性会重写food: &quot;rich&quot;，在这里这并不是我们想要的结果。</p> <p>对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 自身的可枚举属性。 大体上是说当你展开一个对象实例时，你会丢失其方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
  p <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
  <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> clone <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>c <span class="token punctuation">}</span><span class="token punctuation">;</span>
clone<span class="token punctuation">.</span>p<span class="token punctuation">;</span> <span class="token comment">// ok</span>
clone<span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error!</span>
</code></pre></div><p>其次，TypeScript编译器不允许展开泛型函数上的类型参数。 这个特性会在TypeScript的未来版本中考虑实现。</p> <h2 id="接口-interface">接口(interface)</h2> <p>TypeScript的核心原则之一是: <strong>对值所具有的结构进行类型检查</strong>.</p> <p>它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p> <h3 id="接口初探">接口初探</h3> <p>通过下面这个简单的示例来了解接口是如何工作的:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">printLabel</span><span class="token punctuation">(</span><span class="token parameter">labelledObj<span class="token punctuation">:</span> <span class="token punctuation">{</span>label<span class="token punctuation">:</span> string<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>laybelledObj<span class="token punctuation">.</span>label<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> myObj <span class="token operator">=</span> <span class="token punctuation">{</span>size<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> label<span class="token punctuation">:</span> <span class="token string">'Size 10'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">printLabel</span><span class="token punctuation">(</span>myObj<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>类型检查器会查看<code>printLabel</code>的调用. <code>printLabel</code>有一个参数, 并要求这个对象参数有一个名为<code>label</code>类型的<code>string</code>属性.</p> <p>需要注意的是, 我们传入的对象参数实际上会包含很多属性, 但是编译器只会检查那些必需的属性是否存在, 并且其类型是否匹配.
然而, 有时TypeScript并不会这么宽松, 我们下面会稍做讲解.</p> <p>下面, 我们重写上面的例子, 这次使用接口来描述: 必须包含一个<code>label</code>属性且类型为<code>string</code>.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">LabelledValue</span> <span class="token punctuation">{</span>
  label<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">printLabel</span><span class="token punctuation">(</span><span class="token parameter">labelledObj<span class="token punctuation">:</span> LabelledValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>labelledObj<span class="token punctuation">.</span>label<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> myObj <span class="token operator">=</span> <span class="token punctuation">{</span>size<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> label<span class="token punctuation">:</span> <span class="token string">&quot;Size 10 Object&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">printLabel</span><span class="token punctuation">(</span>myObj<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>LabelledValue</code>接口就好比一个名字，用来描述上面例子里的要求。
它代表了有一个<code>label</code>属性且类型为<code>string</code>的对象。
需要注意的是，我们在这里并不能像在其它语言里一样，说传给 printLabel的对象实现了这个接口。
我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。</p> <div class="tip custom-block"><p class="custom-block-title">注意</p> <p>TypeScript类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p></div> <h3 id="可选属性">可选属性</h3> <p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。
可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。</p> <p>下面是应用了“option bags”的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">SquareConfig</span> <span class="token punctuation">{</span>
  color<span class="token operator">?</span><span class="token punctuation">:</span> string<span class="token punctuation">;</span>
  width<span class="token operator">?</span><span class="token punctuation">:</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">createSquare</span><span class="token punctuation">(</span><span class="token parameter">config<span class="token punctuation">:</span> SquareConfig</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>color<span class="token punctuation">:</span> string<span class="token punctuation">;</span> area<span class="token punctuation">:</span> number<span class="token punctuation">}</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> newSquare <span class="token operator">=</span> <span class="token punctuation">{</span>color<span class="token punctuation">:</span> <span class="token string">&quot;white&quot;</span><span class="token punctuation">,</span> area<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span>color<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    newSquare<span class="token punctuation">.</span>color <span class="token operator">=</span> config<span class="token punctuation">.</span>color<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span>width<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    newSquare<span class="token punctuation">.</span>area <span class="token operator">=</span> config<span class="token punctuation">.</span>width <span class="token operator">*</span> config<span class="token punctuation">.</span>width<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> newSquare<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> mySquare <span class="token operator">=</span> <span class="token function">createSquare</span><span class="token punctuation">(</span><span class="token punctuation">{</span>color<span class="token punctuation">:</span> <span class="token string">&quot;black&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个<code>?</code>符号。</p> <p>可选属性的好处:</p> <ul><li>可以对可能存在的属性进行预定义</li> <li>可以捕获引用了不存在的属性时的错误。 比如，我们故意将 createSquare里的color属性名拼错，就会得到一个错误提示.</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">SquareConfig</span> <span class="token punctuation">{</span>
  color<span class="token operator">?</span><span class="token punctuation">:</span> string<span class="token punctuation">;</span>
  width<span class="token operator">?</span><span class="token punctuation">:</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">createSquare</span><span class="token punctuation">(</span><span class="token parameter">config<span class="token punctuation">:</span> SquareConfig</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> color<span class="token punctuation">:</span> string<span class="token punctuation">;</span> area<span class="token punctuation">:</span> number <span class="token punctuation">}</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> newSquare <span class="token operator">=</span> <span class="token punctuation">{</span>color<span class="token punctuation">:</span> <span class="token string">&quot;white&quot;</span><span class="token punctuation">,</span> area<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span>clor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Error: Property 'clor' does not exist on type 'SquareConfig'</span>
    newSquare<span class="token punctuation">.</span>color <span class="token operator">=</span> config<span class="token punctuation">.</span>clor<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span>width<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    newSquare<span class="token punctuation">.</span>area <span class="token operator">=</span> config<span class="token punctuation">.</span>width <span class="token operator">*</span> config<span class="token punctuation">.</span>width<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> newSquare<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> mySquare <span class="token operator">=</span> <span class="token function">createSquare</span><span class="token punctuation">(</span><span class="token punctuation">{</span>color<span class="token punctuation">:</span> <span class="token string">&quot;black&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="只读属性">只读属性</h3> <p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
    readonly x<span class="token punctuation">:</span> number<span class="token punctuation">;</span>
    readonly y<span class="token punctuation">:</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="readon-vs-const">readon vs const</h3> <p>最简单判断该用 readonly 还是 const的方法是看要把它做为变量使用, 还是做为一个属性使用:</p> <ul><li>若作为&quot;变量&quot;, 用const</li> <li>若作为&quot;属性&quot;, 用readonly</li></ul> <h3 id="属性检查">属性检查</h3> <p>首先, 定义一个接口</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">SquareConfig</span> <span class="token punctuation">{</span>
    label<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
    color<span class="token operator">?</span><span class="token punctuation">:</span> string<span class="token punctuation">;</span>
    readonly width<span class="token operator">?</span><span class="token punctuation">:</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>此时, 若我们在调用函数时, 传入如下参数:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> mySquare <span class="token operator">=</span> <span class="token function">createSquare</span><span class="token punctuation">(</span><span class="token punctuation">{</span>colord<span class="token punctuation">:</span> <span class="token string">'black'</span><span class="token punctuation">,</span> label<span class="token punctuation">:</span> <span class="token string">'hello'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>tslint提示语法错误:</p> <div class="language- extra-class"><pre class="language-text"><code>Argument of type {color?: string; label?: string; readonly width: number} is not assignable to parameter of type 'SquareConfig'. Object literal man only specify known properties, but &quot;colord&quot; does not exist in type &quot;SquareConfig&quot;. Did you mean to write &quot;color&quot;?
</code></pre></div><div class="tip custom-block"><p>传入的参数&quot;colord&quot;并不在接口&quot;SquareConfig&quot;的已知属性清单中.</p></div> <p>TypeScript会认为这段代码可能存在bug, 如果一个对象字面量存在任何&quot;目标类型&quot;不包含的属性时, 都会提示错误.
若想绕开这些检查也非常简单, 最简便的方法是使用类型断言.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> mySquare <span class="token operator">=</span> <span class="token function">createSquare</span><span class="token punctuation">(</span><span class="token punctuation">{</span>colord<span class="token punctuation">:</span> <span class="token string">'black'</span><span class="token punctuation">,</span> label<span class="token punctuation">:</span> <span class="token string">'hello'</span><span class="token punctuation">}</span> <span class="token keyword">as</span> SquareConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>然而, 最好的方法是:
添加一个字符串索引签名(前提是, 你能够确定这个对象可能具有某些做为特殊用途使用的额外属性).</p> <p>如果&quot;SquareConfig&quot;带有除上面定义的类型之外的属性, 我们可以这么定义它.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">SquareConfig</span> <span class="token punctuation">{</span>
    label<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
    color<span class="token operator">?</span><span class="token punctuation">:</span> string<span class="token punctuation">;</span>
    readonly width<span class="token operator">?</span><span class="token punctuation">:</span> number<span class="token punctuation">;</span>
    <span class="token punctuation">[</span>option<span class="token punctuation">:</span> string<span class="token punctuation">]</span><span class="token punctuation">:</span> any<span class="token punctuation">;</span>      <span class="token comment">// 其他属性, 可以是任意多个</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="函数类型">函数类型</h3> <p>接口能够描述JavaScript中带属性的普通对象外, 也可以描述函数类型.</p> <p>为了使用接口表示函数类型, 我们需要给接口定义一个调用签名.</p> <p>它就像是一个只有参数列表和返回值类型的函数定义, 参数列表里的每个参数都需要名字和类型.</p> <blockquote><p>如果 interface 有且仅有一个调用签名, 推荐使用此方式替代: <code>type SearchFunc = (source:string, subString: string) =&gt; boolean;</code></p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 接口定义</span>
type <span class="token function-variable function">SearchFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">source<span class="token punctuation">:</span>string<span class="token punctuation">,</span> subString<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> boolean<span class="token punctuation">;</span>

<span class="token keyword">const</span> mySearch<span class="token punctuation">:</span><span class="token function-variable function">SearchFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">source<span class="token punctuation">:</span> string<span class="token punctuation">,</span> subString<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> source<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>subString<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>函数的参数会逐个检查, 要求对应位置上的参数类型是兼容的. 若不指定类型, TypeScript的类型系统会推断出参数类型. 因为函数直接赋值给了SearchFunc类型变量.</p> <p>函数的返回值类型是通过其返回值推断出来的(此例是false或true), 如果让这个函数返回数字或字符串, 类型检查会警告我们函数的返回值类型与SearchFunc接口中的定义不匹配.</p> <h3 id="可索引的类型">可索引的类型</h3> <p>与接口描述函数类型差不多, 我们也可以描述那些能够&quot;通过索引得到&quot;的类型, 如: <code>a[10]</code> 或 <code>ageMap['james']</code>, 可索引类型具胡一个&quot;索引签名&quot;, 它描述了对象索引的类型, 还有相应的索引返回值类型.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">StringArray</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>index<span class="token punctuation">:</span> number<span class="token punctuation">]</span><span class="token punctuation">:</span> string<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> myArray<span class="token punctuation">:</span>StringArray<span class="token punctuation">;</span>
myArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'james'</span><span class="token punctuation">,</span> <span class="token string">'hello'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> myStr<span class="token punctuation">:</span> string <span class="token operator">=</span> myArray<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>上面的例子中, 我们定义了 StringArray接口, 它具有索引签名, 这个索引签名表示了当用 number 去索引 StringArray时会得到 string类型的返回值.</p> <p>TypeScript支持两种索引签名:</p> <ul><li>字符串</li> <li>数字</li></ul> <p>可同时使用两种类型签名, 但是数字索引的返回值必须是字符串索引返回值类型的子类型.
这是因为当使用 number 来索引时, JavaScript会将它转换成 string , 然后再去索引对象. 也就是说, 用100(一个number)去索引等同于&quot;100&quot;(一个string)去索引, 因此两者需要保持一致.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    breed<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">NotOkay</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>x<span class="token punctuation">:</span> number<span class="token punctuation">]</span><span class="token punctuation">:</span> Animal<span class="token punctuation">;</span>
    <span class="token punctuation">[</span>x<span class="token punctuation">:</span> string<span class="token punctuation">]</span><span class="token punctuation">:</span> Dog<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>字符串索引签名能够很好的描述<code>dictionary</code>模式, 并且它们也会确保所有属性与其返回值类型相匹配, 因为字符串索引声明了<code>obj.property</code>和<code>obj['property']</code>两种形式都可以.</p> <p>下面的例子中, name的类型与字符串索引类型不匹配, 所以类型检查器会给出一个错误提示.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">NumberDictionary</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>index<span class="token punctuation">:</span> string<span class="token punctuation">]</span><span class="token punctuation">:</span> number<span class="token punctuation">;</span>
    length<span class="token punctuation">:</span> number<span class="token punctuation">;</span>         <span class="token comment">// 可以, length是number类型</span>
    name<span class="token punctuation">:</span> string<span class="token punctuation">;</span>           <span class="token comment">// 错误, name的类型与索引类型返回值类型不匹配</span>
<span class="token punctuation">}</span>
</code></pre></div><p>正确的写法是:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">NumberDictionary</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>index<span class="token punctuation">:</span> string<span class="token punctuation">]</span><span class="token punctuation">:</span> number<span class="token punctuation">;</span>
    length<span class="token punctuation">:</span> number<span class="token punctuation">;</span>         <span class="token comment">// 可以, length是number类型</span>
    name<span class="token punctuation">:</span> number<span class="token punctuation">;</span>          
<span class="token punctuation">}</span>
</code></pre></div><p>最后, 你可以将索引签名设置为只读, 这样可以防止给索引赋值.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">ReadOnlyStringArray</span> <span class="token punctuation">{</span>
    readonly <span class="token punctuation">[</span>index<span class="token punctuation">:</span> number<span class="token punctuation">]</span><span class="token punctuation">:</span> string<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> roArray<span class="token punctuation">:</span> ReadonlyStringArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'hello'</span><span class="token punctuation">,</span> <span class="token string">'james'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
roArray<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'helloworld'</span>
</code></pre></div><p>此时, 编译器会提出错误信息:</p> <div class="language- extra-class"><pre class="language-text"><code>index signature in type &quot;ReadOnlyStringArray&quot; only permits reading.
</code></pre></div><h3 id="class类型">class类型</h3> <h4 id="实现接口">实现接口</h4> <p>与C#和Java里接口的基本作用一样, TypeScript也能够用它来明确的强制一个类去符合某种契约.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">ClockInterface</span> <span class="token punctuation">{</span>
    currentTime<span class="token punctuation">:</span> Date<span class="token punctuation">;</span>
    <span class="token function">setTime</span><span class="token punctuation">(</span>d<span class="token punctuation">:</span> Date<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Clock</span> <span class="token keyword">implements</span> <span class="token class-name">ClockInterface</span> <span class="token punctuation">{</span>
    currentTime<span class="token punctuation">:</span> Date<span class="token punctuation">;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">h<span class="token punctuation">:</span> number<span class="token punctuation">,</span> m<span class="token punctuation">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        window<span class="token punctuation">.</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">setTime</span><span class="token punctuation">(</span>d<span class="token punctuation">:</span> Date<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>currentTime <span class="token operator">=</span> d<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>接口仅仅只描述类的<strong>公共部分</strong>, 它不会帮你检查是否有某些私有成员.</p></blockquote> <h4 id="class静态部分和实例部分的区别">class静态部分和实例部分的区别</h4> <p>class包含有两部分的类型:</p> <ul><li>静态部分</li> <li>实例</li></ul> <p>你会注意到, 当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时, 会得到一个错误:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">ClockConstructor</span> <span class="token punctuation">{</span>
    <span class="token keyword">new</span><span class="token punctuation">(</span>hour<span class="token punctuation">:</span> number<span class="token punctuation">,</span> minute<span class="token punctuation">:</span> number<span class="token punctuation">)</span><span class="token punctuation">:</span> any<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">NewClock</span> <span class="token keyword">implements</span> <span class="token class-name">ClockConstructor</span> <span class="token punctuation">{</span>
    currentTime<span class="token punctuation">:</span> Date<span class="token punctuation">;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">h<span class="token punctuation">:</span> number<span class="token punctuation">,</span> m<span class="token punctuation">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        window<span class="token punctuation">.</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>因为当一个 class 实现了一个接口时, 只对其实例部分进行类型检查, constructor 属于 class 静态部分, 所以不在检查的范围内.
因此, 我们应该只操作class的静态部分.</p> <p>下面的例子中, 我们定义了两个接口:</p> <ul><li>ClockConstructor为构造函数所用</li> <li>ClockInterface为实例方法所用</li></ul> <p>为了方便, 我们定义了一个构造函数 createClock, 它用传入的类型创建实例.</p> <div class="language-js extra-class"><pre class="language-js"><code>type ClockConstructor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token parameter">hour<span class="token punctuation">:</span> number<span class="token punctuation">,</span> minute<span class="token punctuation">:</span> number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> ClockInterface<span class="token punctuation">;</span>

<span class="token keyword">interface</span> <span class="token class-name">ClockInterface</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">tick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">createClock</span><span class="token punctuation">(</span><span class="token parameter">ctor<span class="token punctuation">:</span> ClockConstructor<span class="token punctuation">,</span> hour<span class="token punctuation">:</span> number<span class="token punctuation">,</span> minute<span class="token punctuation">:</span> number</span><span class="token punctuation">)</span><span class="token punctuation">:</span> ClockInterface <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ctor</span><span class="token punctuation">(</span>hour<span class="token punctuation">,</span> minute<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">DigitalClock</span> <span class="token keyword">implements</span> <span class="token class-name">ClockInterface</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">h<span class="token punctuation">:</span> number<span class="token punctuation">,</span> m<span class="token punctuation">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        window<span class="token punctuation">.</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">tick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span><span class="token punctuation">{</span>
        window<span class="token punctuation">.</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'beep beep'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> digital <span class="token operator">=</span> <span class="token function">createClock</span><span class="token punctuation">(</span>DigitalClock<span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>因为createClock 的第一个参数是DigitalClock类型, 在createClock(DigitalClock, 12, 17)里, 会检查DigitalClock是否符合构造函数签名.</p> <h4 id="继承接口">继承接口</h4> <p>和class一样, 接口也可以相互继承.</p> <p>这让我们能够从一个接口里复制成员到另一个接口里, 可以更灵活地将接口分割到可重用的模块里.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>
    color<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">interface</span> <span class="token class-name">Square</span> <span class="token keyword">extends</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>
    sideLength<span class="token punctuation">:</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> square <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">as</span> Square<span class="token punctuation">;</span>
square<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">'blue'</span><span class="token punctuation">;</span>
square<span class="token punctuation">.</span>sideLength <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre></div><p>一个接口可以继承多个接口, 创建出多个接口的合成接口.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>
    color<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">PerStroke</span> <span class="token punctuation">{</span>
    penWidth<span class="token punctuation">:</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Square</span> <span class="token keyword">extends</span> <span class="token class-name">Shape</span><span class="token punctuation">,</span> PerStroke <span class="token punctuation">{</span>
    sideLength<span class="token punctuation">:</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> square <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">as</span> Square<span class="token punctuation">;</span>
square<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">'blue'</span><span class="token punctuation">;</span>
square<span class="token punctuation">.</span>sideLength <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
square<span class="token punctuation">.</span>penWidth <span class="token operator">=</span> <span class="token number">5.0</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="混合类型">混合类型</h4> <p>接口能够描述JavaScript中丰富的类型.
因为JavaScript的动态灵活的特性, 有时你可能需要一个对象同时具有多种类型.</p> <p>例如, 一个对象可以同时作为函数和对象使用, 并带有额外的属性.</p> <div class="language-js extra-class"><pre class="language-js"><code>interfact Counter<span class="token punctuation">{</span>
    <span class="token punctuation">(</span>start<span class="token punctuation">:</span> number<span class="token punctuation">)</span><span class="token punctuation">:</span> string<span class="token punctuation">;</span>
    interval<span class="token punctuation">:</span> nmber<span class="token punctuation">;</span>
    <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">getCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>Counter<span class="token punctuation">{</span>
    <span class="token keyword">const</span> counter <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">start<span class="token punctuation">:</span> number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        window<span class="token punctuation">.</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">as</span> Counter<span class="token punctuation">;</span>
    counter<span class="token punctuation">.</span><span class="token function-variable function">reset</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        window<span class="token punctuation">.</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'counter.reset()'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> counter<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token function">getCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">c</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span>interval <span class="token operator">=</span> <span class="token number">5.0</span><span class="token punctuation">;</span>
</code></pre></div><p>在使用JavaScript第三方库的时候, 你可能需要像上面那样去完整定义类型.</p> <h4 id="接口继承类">接口继承类</h4> <p>当接口继承了一个<code>class</code>类型时, 它会继承<code>class</code>的成员, 但不包括其实现. 就好像接口声明了类中存在的成员, 但并没有提供具体的实现一样.</p> <p>接口同样会继承类的<code>private</code>和<code>protected</code>成员, 这意味着当你创建了一个接口继承了一个拥有<code>private</code>或<code>protected</code>成员的<code>class</code>时, 这个接口类型只能被这个<code>class</code>或其子类所实现(<code>implement</code>).</p> <p>当你有一个庞大的继承结构时, 会很有用.
但要指出的, 你的代码只在子类拥有特定属性时起作用, 这个子类除了继承自基类外, 与基类没有任何关系.</p> <p>例如:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Control</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> state<span class="token punctuation">:</span> any<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

interfact SelectableControl <span class="token keyword">extends</span> <span class="token class-name">Control</span> <span class="token punctuation">{</span>
    <span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Button</span> <span class="token keyword">extends</span> <span class="token class-name">Control</span> <span class="token keyword">implements</span> <span class="token class-name">SelectableControl</span> <span class="token punctuation">{</span>
    <span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">void</span> <span class="token punctuation">{</span>
        window<span class="token punctuation">.</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;button select&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">TextBox</span> <span class="token keyword">extends</span> <span class="token class-name">Control</span> <span class="token punctuation">{</span>
    <span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
        window<span class="token punctuation">.</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;textbox select&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 错误, ImageBox类型缺少state属性</span>
<span class="token keyword">class</span> <span class="token class-name">ImageBox</span> <span class="token keyword">implements</span> <span class="token class-name">SelectableControl</span> <span class="token punctuation">{</span>
    <span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
        window<span class="token punctuation">.</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;image select&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>编译将会出错:</p> <div class="language- extra-class"><pre class="language-text"><code>Class &quot;ImageBox&quot; incorrectly implements interfact &quot;SelectableControl&quot;. 
    Property &quot;state&quot; is missing in type &quot;ImageBox&quot; but required in type &quot;SelectableControl&quot;.
</code></pre></div><p>在上面的示例中:
<code>SelectableControl</code> 包含了<code>Control</code>所有的成员, 包括<code>private</code>成员<code>state</code>. 因为<code>state</code>是<code>private</code>私有成员, 所以只能够是<code>Control</code>的子类们才能实现<code>SelectableControl</code>接口.</p> <blockquote><p>因为只有&quot;Control&quot;的子类才会拥有一个<code>Control</code>的私有成员<code>state</code>, 这对私有成员的兼容性是必需的.</p></blockquote> <p>在<code>Control</code>内部, 是允许通过<code>SelectableControl</code>的实例来访问私有成员<code>state</code>的. 实际上, <code>SelectableControl</code>接口和拥有<code>select</code>方法的<code>Control</code>类是一样的.</p> <p><code>Button</code>和<code>TextBox</code>类是<code>SelectableControl</code>的子类(因为它们都继承至<code>Control</code>并有<code>select</code>方法), 但<code>ImageBox</code>类没有.</p> <h2 id="类-class">类(class)</h2> <p>传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。
从ECMAScript 2015，也就是ECMAScript 6开始，JavaScript程序员将能够使用基于类的面向对象的方式。
使用TypeScript，我们允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript版本。</p> <h3 id="类-2">类</h3> <p>下面看一个使用类的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Greeter</span> <span class="token punctuation">{</span>
    greeting<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">message<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>greeting <span class="token operator">=</span> message<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;Hello, &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>greeting<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> greeter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Greeter</span><span class="token punctuation">(</span><span class="token string">&quot;world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果你使用过C#或Java，你会对这种语法非常熟悉。 我们声明一个 Greeter类。这个类有3个成员：一个叫做 greeting的属性，一个构造函数和一个 greet方法。</p> <p>你会注意到，我们在引用任何一个类成员的时候都用了 this。 它表示我们访问的是类的成员。</p> <p>最后一行，我们使用 new构造了 Greeter类的一个实例。 它会调用之前定义的构造函数，创建一个 Greeter类型的新对象，并执行构造函数初始化它。</p> <h3 id="继承">继承</h3> <p>在TypeScript里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。</p> <p>看下面的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token function">move</span><span class="token punctuation">(</span><span class="token parameter">distanceInMeters<span class="token punctuation">:</span> number <span class="token operator">=</span> <span class="token number">0</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Animal moved </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>distanceInMeters<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">m.`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token function">bark</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Woof! Woof!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
dog<span class="token punctuation">.</span><span class="token function">bark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
dog<span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
dog<span class="token punctuation">.</span><span class="token function">bark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这个例子展示了最基本的继承：类从基类中继承了属性和方法。
这里， Dog是一个 派生类，它派生自 Animal 基类，通过 <code>extends</code>关键字。 派生类通常被称作 <strong>子类</strong>，基类通常被称作 <strong>超类</strong>。</p> <p>因为 Dog继承了 Animal的功能，因此我们可以创建一个 Dog的实例，它能够 bark()和 move()。</p> <p>下面我们来看个更加复杂的例子。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">theName<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> theName<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token function">move</span><span class="token punctuation">(</span><span class="token parameter">distanceInMeters<span class="token punctuation">:</span> number <span class="token operator">=</span> <span class="token number">0</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> moved </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>distanceInMeters<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">m.`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Snake</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token function">move</span><span class="token punctuation">(</span><span class="token parameter">distanceInMeters <span class="token operator">=</span> <span class="token number">5</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Slithering...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span>distanceInMeters<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Horse</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token function">move</span><span class="token punctuation">(</span><span class="token parameter">distanceInMeters <span class="token operator">=</span> <span class="token number">45</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Galloping...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span>distanceInMeters<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> sam <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Snake</span><span class="token punctuation">(</span><span class="token string">&quot;Sammy the Python&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> tom<span class="token punctuation">:</span> Animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Horse</span><span class="token punctuation">(</span><span class="token string">&quot;Tommy the Palomino&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

sam<span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
tom<span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">34</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这个例子展示了一些上面没有提到的特性。 这一次，我们使用 extends关键字创建了 Animal的两个子类： Horse和 Snake。</p> <div class="tip custom-block"><p class="custom-block-title">注意</p> <p>与前一个例子的不同点是，派生类包含了一个构造函数，它 必须调用 super()，它会执行基类的构造函数。
而且，在构造函数里访问 this的属性之前，我们 一定要调用 super()。
这个是TypeScript强制执行的一条重要规则。</p></div> <p>这个例子演示了如何在子类里可以重写父类的方法。
Snake类和 Horse类都创建了 move方法，它们重写了从 Animal继承来的 move方法，使得 move方法根据不同的类而具有不同的功能。
注意，即使 tom被声明为 Animal类型，但因为它的值是 Horse，调用 tom.move(34)时，它会调用 Horse里重写的方法：</p> <div class="language- extra-class"><pre class="language-text"><code>Slithering...
Sammy the Python moved 5m.
Galloping...
Tommy the Palomino moved 34m.
</code></pre></div><h3 id="默认为-public">默认为 public</h3> <p>在上面的例子里，我们可以自由的访问程序里定义的成员。
如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用 public来做修饰；
例如，C#要求必须明确地使用 public指定成员是可见的。</p> <div class="tip custom-block"><p>在TypeScript里，成员都默认为 public。</p></div> <p>你也可以明确的将一个成员标记成 public。 我们可以用下面的方式来重写上面的 Animal类：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> name<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">theName<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> theName<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token parameter">distanceInMeters<span class="token punctuation">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> moved </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>distanceInMeters<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">m.`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="private">private</h3> <p>当成员被标记成 <code>private</code>时，它就不能在声明它的类的外部访问。</p> <p>比如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> name<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">theName<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> theName<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">&quot;Cat&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span> <span class="token comment">// 错误: 'name' 是私有的.</span>
</code></pre></div><div class="tip custom-block"><p>TypeScript使用的是结构性类型系统。
当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。</p></div> <p>然而，当我们比较带有 <code>private</code>或 <code>protected</code>成员的类型的时候，情况就不同了。
如果其中一个类型里包含一个 private成员，那么只有当另外一个类型中也存在这样一个 private成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。
对于 protected成员也使用这个规则。</p> <p>下面来看一个例子，更好地说明了这一点：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> name<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">theName<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> theName<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Rhino</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token string">&quot;Rhino&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> name<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">theName<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> theName<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">&quot;Goat&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> rhino <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rhino</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> employee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">&quot;Bob&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

animal <span class="token operator">=</span> rhino<span class="token punctuation">;</span>
animal <span class="token operator">=</span> employee<span class="token punctuation">;</span> <span class="token comment">// 错误: Animal 与 Employee 不兼容.</span>
</code></pre></div><p>这个例子中有 Animal和 Rhino两个类， Rhino是 Animal类的子类。
还有一个 Employee类，其类型看上去与 Animal是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。
因为 Animal和 Rhino共享了来自 Animal里的私有成员定义 private name: string，因此它们是兼容的。
然而 Employee却不是这样。当把 Employee赋值给 Animal的时候，得到一个错误，说它们的类型不兼容。
尽管 Employee里也有一个私有成员 name，但它明显不是 Animal里面定义的那个。</p> <h3 id="protected">protected</h3> <p><code>protected</code>修饰符与 <code>private</code>修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问。</p> <p>例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">protected</span> name<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> department<span class="token punctuation">:</span> string<span class="token punctuation">;</span>

    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">:</span> string<span class="token punctuation">,</span> department<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>department <span class="token operator">=</span> department<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token function">getElevatorPitch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`Hello, my name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> and I work in </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>department<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.`</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> howard <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">&quot;Howard&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Sales&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>howard<span class="token punctuation">.</span><span class="token function">getElevatorPitch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>howard<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误</span>
</code></pre></div><p>注意，我们不能在 Person类外使用 name，但是我们仍然可以通过 Employee类的实例方法访问，因为 Employee是由 Person派生而来的。</p> <p>构造函数也可以被标记成 <code>protected</code>。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如，</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">protected</span> name<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">theName<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> theName<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// Employee 能够继承 Person</span>
<span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> department<span class="token punctuation">:</span> string<span class="token punctuation">;</span>

    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">:</span> string<span class="token punctuation">,</span> department<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>department <span class="token operator">=</span> department<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token function">getElevatorPitch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`Hello, my name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> and I work in </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>department<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.`</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> howard <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">&quot;Howard&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Sales&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> john <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;John&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误: 'Person' 的构造函数是被保护的.</span>
</code></pre></div><h3 id="readonly修饰符">readonly修饰符</h3> <p>你可以使用 readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Octopus</span> <span class="token punctuation">{</span>
    readonly name<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
    readonly numberOfLegs<span class="token punctuation">:</span> number <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
    <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">theName<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> theName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> dad <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Octopus</span><span class="token punctuation">(</span><span class="token string">&quot;Man with the 8 strong legs&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
dad<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Man with the 3-piece suit&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 错误! name 是只读的.</span>
</code></pre></div><h3 id="参数属性">参数属性</h3> <p>在上面的例子中，我们必须在Octopus类里定义一个只读成员 name和一个参数为 theName的构造函数，并且立刻将 theName的值赋给 name，这种情况经常会遇到。
参数属性可以方便地让我们在一个地方定义并初始化一个成员。</p> <p>下面的例子是对之前 Octopus类的修改版，使用了参数属性：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Octopus</span> <span class="token punctuation">{</span>
    readonly numberOfLegs<span class="token punctuation">:</span> number <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">readonly name<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意看我们是如何舍弃了 theName，仅在构造函数里使用 readonly name: string参数来创建和初始化 name成员。 我们把声明和赋值合并至一处。</p> <p>参数属性通过给构造函数参数前面添加一个访问限定符来声明。
使用 <code>private</code>限定一个参数属性会声明并初始化一个私有成员；对于 public和 protected来说也是一样。</p> <h3 id="存取器">存取器</h3> <p>TypeScript支持通过<code>getters/setters</code>来截取对对象成员的访问。
它能帮助你有效的控制对对象成员的访问。</p> <p>下面来看如何把一个简单的类改写成使用 get和 set。 首先，我们从一个没有使用存取器的例子开始。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
    fullName<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> employee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
employee<span class="token punctuation">.</span>fullName <span class="token operator">=</span> <span class="token string">&quot;Bob Smith&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>employee<span class="token punctuation">.</span>fullName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>employee<span class="token punctuation">.</span>fullName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们可以随意的设置 fullName，这是非常方便的，但是这也可能会带来麻烦。</p> <p>下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改员工信息。 我们把对 fullName的直接访问改成了可以检查密码的 set方法。
我们也加了一个 get方法，让上面的例子仍然可以工作。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> passcode <span class="token operator">=</span> <span class="token string">&quot;secret passcode&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> _fullName<span class="token punctuation">:</span> string<span class="token punctuation">;</span>

    <span class="token keyword">get</span> <span class="token function">fullName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> string <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_fullName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">set</span> <span class="token function">fullName</span><span class="token punctuation">(</span><span class="token parameter">newName<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>passcode <span class="token operator">&amp;&amp;</span> passcode <span class="token operator">==</span> <span class="token string">&quot;secret passcode&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>_fullName <span class="token operator">=</span> newName<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Error: Unauthorized update of employee!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> employee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
employee<span class="token punctuation">.</span>fullName <span class="token operator">=</span> <span class="token string">&quot;Bob Smith&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>employee<span class="token punctuation">.</span>fullName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span>employee<span class="token punctuation">.</span>fullName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们可以修改一下密码，来验证一下存取器是否是工作的。
当密码不对时，会提示我们没有权限去修改员工。</p> <div class="tip custom-block"><p class="custom-block-title">存取器使用注意事项：</p> <ul><li>存取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。</li> <li>只带有 get不带有 set的存取器自动被推断为 readonly。</li></ul> <p>这在从代码生成 .d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。</p></div> <h3 id="静态属性-static">静态属性(static)</h3> <p>到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。
我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。
在这个例子里，我们使用 <code>static</code>定义 <code>origin</code>，因为它是所有网格都会用到的属性。
每个实例想要访问这个属性的时候，都要在 origin前面加上类名。
如同在实例属性上使用 <code>this.</code>前缀来访问属性一样，
这里我们使用 <code>Grid.</code>来访问静态属性。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Grid</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> origin <span class="token operator">=</span> <span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">calculateDistanceFromOrigin</span><span class="token punctuation">(</span><span class="token parameter">point<span class="token punctuation">:</span> <span class="token punctuation">{</span>x<span class="token punctuation">:</span> number<span class="token punctuation">;</span> y<span class="token punctuation">:</span> number<span class="token punctuation">;</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> xDist <span class="token operator">=</span> <span class="token punctuation">(</span>point<span class="token punctuation">.</span>x <span class="token operator">-</span> Grid<span class="token punctuation">.</span>origin<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> yDist <span class="token operator">=</span> <span class="token punctuation">(</span>point<span class="token punctuation">.</span>y <span class="token operator">-</span> Grid<span class="token punctuation">.</span>origin<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>xDist <span class="token operator">*</span> xDist <span class="token operator">+</span> yDist <span class="token operator">*</span> yDist<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">this</span><span class="token punctuation">.</span>scale<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">public</span> scale<span class="token punctuation">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> grid1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Grid</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 1x scale</span>
<span class="token keyword">let</span> grid2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Grid</span><span class="token punctuation">(</span><span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 5x scale</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>grid1<span class="token punctuation">.</span><span class="token function">calculateDistanceFromOrigin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>grid2<span class="token punctuation">.</span><span class="token function">calculateDistanceFromOrigin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="抽象类">抽象类</h3> <p>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。
不同于接口，抽象类可以包含成员的实现细节。</p> <div class="tip custom-block"><p><code>abstract</code>关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p></div> <div class="language-js extra-class"><pre class="language-js"><code>abstract <span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    abstract <span class="token function">makeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
    <span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'roaming the earch...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。
抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。
然而，抽象方法必须包含 <code>abstract</code>关键字并且可以包含访问修饰符。</p> <div class="language-js extra-class"><pre class="language-js"><code>abstract <span class="token keyword">class</span> <span class="token class-name">Department</span> <span class="token punctuation">{</span>

    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">public</span> name<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Department name: '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    abstract <span class="token function">printMeeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token comment">// 必须在派生类中实现</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">AccountingDepartment</span> <span class="token keyword">extends</span> <span class="token class-name">Department</span> <span class="token punctuation">{</span>

    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token string">'Accounting and Auditing'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在派生类的构造函数中必须调用 super()</span>
    <span class="token punctuation">}</span>

    <span class="token function">printMeeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'The Accounting Department meets each Monday at 10am.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">generateReports</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Generating accounting reports...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> department<span class="token punctuation">:</span> Department<span class="token punctuation">;</span> <span class="token comment">// 允许创建一个对抽象类型的引用</span>
department <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Department</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误: 不能创建一个抽象类的实例</span>
department <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AccountingDepartment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 允许对一个抽象子类进行实例化和赋值</span>
department<span class="token punctuation">.</span><span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
department<span class="token punctuation">.</span><span class="token function">printMeeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
department<span class="token punctuation">.</span><span class="token function">generateReports</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误: 方法在声明的抽象类中不存在</span>
</code></pre></div><h3 id="构造函数-高级技巧">构造函数(高级技巧)</h3> <p>当你在TypeScript里声明了一个类的时候，实际上同时声明了很多东西。
首先就是类的 实例的类型。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Greeter</span> <span class="token punctuation">{</span>
    greeting<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">message<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>greeting <span class="token operator">=</span> message<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;Hello, &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>greeting<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> greeter<span class="token punctuation">:</span> Greeter<span class="token punctuation">;</span>
greeter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Greeter</span><span class="token punctuation">(</span><span class="token string">&quot;world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>greeter<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这里，我们写了 let greeter: Greeter，意思是 Greeter类的实例的类型是 Greeter。
这对于用过其它面向对象语言的程序员来讲已经是老习惯了。</p> <p>我们也创建了一个叫做 <code>构造函数</code>的方法。
这个函数会在我们使用 <code>new</code>创建类实例的时候被调用。
下面我们来看看，上面的代码被编译成JavaScript后是什么样子的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> Greeter <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token function">Greeter</span><span class="token punctuation">(</span><span class="token parameter">message</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>greeting <span class="token operator">=</span> message<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">Greeter</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">greet</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;Hello, &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>greeting<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> Greeter<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> greeter<span class="token punctuation">;</span>
greeter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Greeter</span><span class="token punctuation">(</span><span class="token string">&quot;world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>greeter<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上面的代码里， <code>let Greeter</code>将被赋值为构造函数。
当我们调用 new并执行了这个函数后，便会得到一个类的实例。 这个构造函数也包含了类的所有静态属性。
换个角度说，我们可以认为类具有 <strong>实例部分</strong>与 <strong>静态部分</strong>这两个部分。</p> <p>让我们稍微改写一下这个例子，看看它们之间的区别：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Greeter</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> standardGreeting <span class="token operator">=</span> <span class="token string">&quot;Hello, there&quot;</span><span class="token punctuation">;</span>
    greeting<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
    <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>greeting<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token string">&quot;Hello, &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>greeting<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> Greeter<span class="token punctuation">.</span>standardGreeting<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> greeter1<span class="token punctuation">:</span> Greeter<span class="token punctuation">;</span>
greeter1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Greeter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>greeter1<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> greeterMaker<span class="token punctuation">:</span> <span class="token keyword">typeof</span> Greeter <span class="token operator">=</span> Greeter<span class="token punctuation">;</span>
greeterMaker<span class="token punctuation">.</span>standardGreeting <span class="token operator">=</span> <span class="token string">&quot;Hey there!&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> greeter2<span class="token punctuation">:</span> Greeter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">greeterMaker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>greeter2<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这个例子里， greeter1与之前看到的一样。 我们实例化 Greeter类，并使用这个对象。 与我们之前看到的一样。</p> <p>再之后，我们直接使用类。 我们创建了一个叫做 greeterMaker的变量。 这个变量保存了这个类或者说保存了类构造函数。
然后我们使用 <code>typeof Greeter</code>，意思是取Greeter类的类型，而不是实例的类型。 或者更确切的说，&quot;告诉我 Greeter标识符的类型&quot;，也就是构造函数的类型。
这个类型包含了类的所有静态成员和构造函数。
之后，就和前面一样，我们在 greeterMaker上使用 <code>new</code>，创建 Greeter的实例。</p> <h3 id="把类当做接口使用">把类当做接口使用</h3> <p>如上一节里所讲的，类定义会创建两个东西：</p> <ul><li>类的实例类型</li> <li>构造函数。</li></ul> <p>因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">:</span> number<span class="token punctuation">;</span>
    y<span class="token punctuation">:</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Point3d</span> <span class="token keyword">extends</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
    z<span class="token punctuation">:</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> point3d<span class="token punctuation">:</span> Point3d <span class="token operator">=</span> <span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> z<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="函数-function">函数(function)</h2> <p>函数是JavaScript应用程序的基础。
它帮助你实现抽象层，模拟类，信息隐藏和模块。
在TypeScript里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的地方。
TypeScript为JavaScript函数添加了额外的功能，让我们可以更容易地使用。</p> <h3 id="函数">函数</h3> <p>和JavaScript一样，TypeScript函数可以创建有名字的函数和匿名函数。
你可以随意选择适合应用程序的方式，不论是定义一系列API函数还是只使用一次的函数。</p> <p>通过下面的例子可以迅速回想起这两种JavaScript中的函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Named function</span>
<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Anonymous function</span>
<span class="token keyword">let</span> <span class="token function-variable function">myAdd</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>在JavaScript里，函数可以使用函数体外部的变量。
当函数这么做时，我们说它‘捕获’了这些变量。
至于为什么可以这样做以及其中的利弊超出了本文的范围，但是深刻理解这个机制对学习JavaScript和TypeScript会很有帮助。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> z <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">addToZ</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="函数类型-2">函数类型</h3> <h4 id="为函数定义类型">为函数定义类型</h4> <p>让我们为上面那个函数添加类型：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">:</span> number<span class="token punctuation">,</span> y<span class="token punctuation">:</span> number</span><span class="token punctuation">)</span><span class="token punctuation">:</span> number <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> <span class="token function-variable function">myAdd</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">:</span> number<span class="token punctuation">,</span> y<span class="token punctuation">:</span> number</span><span class="token punctuation">)</span><span class="token punctuation">:</span> number <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>我们可以给每个参数添加类型之后再为函数本身添加返回值类型。
TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它。</p> <h4 id="书写完整函数类型">书写完整函数类型</h4> <p>现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">myAdd</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">:</span> number<span class="token punctuation">,</span> y<span class="token punctuation">:</span> number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function-variable function">number</span> <span class="token operator">=</span>
    <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">:</span> number<span class="token punctuation">,</span> y<span class="token punctuation">:</span> number</span><span class="token punctuation">)</span><span class="token punctuation">:</span> number <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>函数类型包含两部分：</p> <ul><li>参数类型</li> <li>返回值类型</li></ul> <p>当写出完整函数类型的时候，这两部分都是需要的。
我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。
这个名字只是为了增加可读性。 我们也可以这么写：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">myAdd</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter">baseValue<span class="token punctuation">:</span> number<span class="token punctuation">,</span> increment<span class="token punctuation">:</span> number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function-variable function">number</span> <span class="token operator">=</span>
    <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">:</span> number<span class="token punctuation">,</span> y<span class="token punctuation">:</span> number</span><span class="token punctuation">)</span><span class="token punctuation">:</span> number <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。</p> <p>第二部分是返回值类型。
对于返回值，我们在函数和返回值类型之前使用( =&gt;)符号，使之清晰明了。
如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 void而不能留空。</p> <p>函数的类型只是由参数类型和返回值组成的。 函数中使用的捕获变量不会体现在类型里。 实际上，这些变量是函数的隐藏状态并不是组成API的一部分。</p> <h3 id="推断类型">推断类型</h3> <p>尝试这个例子的时候，你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript编译器会自动识别出类型：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// myAdd has the full function type</span>
<span class="token keyword">let</span> <span class="token function-variable function">myAdd</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">:</span> number<span class="token punctuation">,</span> y<span class="token punctuation">:</span> number</span><span class="token punctuation">)</span><span class="token punctuation">:</span> number <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// The parameters `x` and `y` have the type number</span>
<span class="token keyword">let</span> <span class="token function-variable function">myAdd</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter">baseValue<span class="token punctuation">:</span> number<span class="token punctuation">,</span> increment<span class="token punctuation">:</span> number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function-variable function">number</span> <span class="token operator">=</span>
    <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>这叫做“按上下文归类”，是类型推论的一种。 它帮助我们更好地为程序指定类型。</p> <h3 id="可选参数和默认参数">可选参数和默认参数</h3> <p>TypeScript里的每个函数参数都是必须的。
这不是指不能传递 null或undefined作为参数，而是说编译器检查用户是否为每个参数都传入了值。
编译器还会假设只有这些参数会被传递进函数。
简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token parameter">firstName<span class="token punctuation">:</span> string<span class="token punctuation">,</span> lastName<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> firstName <span class="token operator">+</span> <span class="token string">&quot; &quot;</span> <span class="token operator">+</span> lastName<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> result1 <span class="token operator">=</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token string">&quot;Bob&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// error, too few parameters</span>
<span class="token keyword">let</span> result2 <span class="token operator">=</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token string">&quot;Bob&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Adams&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Sr.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// error, too many parameters</span>
<span class="token keyword">let</span> result3 <span class="token operator">=</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token string">&quot;Bob&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Adams&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// ah, just right</span>
</code></pre></div><p>JavaScript里，每个参数都是可选的，可传可不传。
没传参的时候，它的值就是undefined。</p> <div class="tip custom-block"><p>在TypeScript里我们可以在参数名旁使用 <code>?</code>实现可选参数的功能。</p></div> <p>比如，我们想让last name是可选的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token parameter">firstName<span class="token punctuation">:</span> string<span class="token punctuation">,</span> lastName<span class="token operator">?</span><span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>lastName<span class="token punctuation">)</span>
        <span class="token keyword">return</span> firstName <span class="token operator">+</span> <span class="token string">&quot; &quot;</span> <span class="token operator">+</span> lastName<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> firstName<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> result1 <span class="token operator">=</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token string">&quot;Bob&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// works correctly now</span>
<span class="token keyword">let</span> result2 <span class="token operator">=</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token string">&quot;Bob&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Adams&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Sr.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// error, too many parameters</span>
<span class="token keyword">let</span> result3 <span class="token operator">=</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token string">&quot;Bob&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Adams&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ah, just right</span>
</code></pre></div><p>可选参数必须跟在必须参数后面。 如果上例我们想让first name是可选的，那么就必须调整它们的位置，把first name放在后面。</p> <p>在TypeScript里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是undefined时。
它们叫做有默认初始化值的参数。
让我们修改上例，把last name的默认值设置为&quot;Smith&quot;。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">buildName</span><span class="token punctuation">(</span>firstName<span class="token punctuation">:</span> string<span class="token punctuation">,</span> lastName <span class="token operator">=</span> <span class="token string">&quot;Smith&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> firstName <span class="token operator">+</span> <span class="token string">&quot; &quot;</span> <span class="token operator">+</span> lastName<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> result1 <span class="token operator">=</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token string">&quot;Bob&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// works correctly now, returns &quot;Bob Smith&quot;</span>
<span class="token keyword">let</span> result2 <span class="token operator">=</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token string">&quot;Bob&quot;</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// still works, also returns &quot;Bob Smith&quot;</span>
<span class="token keyword">let</span> result3 <span class="token operator">=</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token string">&quot;Bob&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Adams&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Sr.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// error, too many parameters</span>
<span class="token keyword">let</span> result4 <span class="token operator">=</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token string">&quot;Bob&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Adams&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// ah, just right</span>
</code></pre></div><p>在所有必须参数后面的带默认初始化的参数都是可选的，与可选参数一样，在调用函数的时候可以省略。 也就是说可选参数与末尾的默认参数共享参数类型。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token parameter">firstName<span class="token punctuation">:</span> string<span class="token punctuation">,</span> lastName<span class="token operator">?</span><span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>和</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">buildName</span><span class="token punctuation">(</span>firstName<span class="token punctuation">:</span> string<span class="token punctuation">,</span> lastName <span class="token operator">=</span> <span class="token string">&quot;Smith&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>共享同样的类型(firstName: string, lastName?: string) =&gt; string。
默认参数的默认值消失了，只保留了它是一个可选参数的信息。</p> <p>与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。
如果带默认值的参数出现在必须参数前面，用户必须明确的传入 undefined值来获得默认值。</p> <p>例如，我们重写最后一个例子，让 firstName是带默认值的参数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">buildName</span><span class="token punctuation">(</span>firstName <span class="token operator">=</span> <span class="token string">&quot;Will&quot;</span><span class="token punctuation">,</span> lastName<span class="token punctuation">:</span> string<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> firstName <span class="token operator">+</span> <span class="token string">&quot; &quot;</span> <span class="token operator">+</span> lastName<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> result1 <span class="token operator">=</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token string">&quot;Bob&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// error, too few parameters</span>
<span class="token keyword">let</span> result2 <span class="token operator">=</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token string">&quot;Bob&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Adams&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Sr.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// error, too many parameters</span>
<span class="token keyword">let</span> result3 <span class="token operator">=</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token string">&quot;Bob&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Adams&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// okay and returns &quot;Bob Adams&quot;</span>
<span class="token keyword">let</span> result4 <span class="token operator">=</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token string">&quot;Adams&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// okay and returns &quot;Will Adams&quot;</span>
</code></pre></div><h3 id="剩余参数">剩余参数</h3> <p>默认参数和可选参数有个共同点：它们表示某一个参数。</p> <p>有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。
在JavaScript里，你可以使用 arguments来访问所有传入的参数。</p> <p>在TypeScript里，你可以把所有参数收集到一个变量里：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token parameter">firstName<span class="token punctuation">:</span> string<span class="token punctuation">,</span> <span class="token operator">...</span>restOfName<span class="token punctuation">:</span> string<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> firstName <span class="token operator">+</span> <span class="token string">&quot; &quot;</span> <span class="token operator">+</span> restOfName<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> employeeName <span class="token operator">=</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token string">&quot;Joseph&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Samuel&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Lucas&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;MacKinzie&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（ ...）后面给定的名字，你可以在函数体内使用这个数组。</p> <p>这个省略号也会在带有剩余参数的函数类型定义上使用到：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token parameter">firstName<span class="token punctuation">:</span> string<span class="token punctuation">,</span> <span class="token operator">...</span>restOfName<span class="token punctuation">:</span> string<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> firstName <span class="token operator">+</span> <span class="token string">&quot; &quot;</span> <span class="token operator">+</span> restOfName<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> <span class="token function-variable function">buildNameFun</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter">fname<span class="token punctuation">:</span> string<span class="token punctuation">,</span> <span class="token operator">...</span>rest<span class="token punctuation">:</span> string<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> string <span class="token operator">=</span> buildName<span class="token punctuation">;</span>
</code></pre></div><h3 id="this">this</h3> <p>学习如何在JavaScript里正确使用<code>this</code>就好比一场成年礼。
由于TypeScript是JavaScript的超集，TypeScript程序员也需要弄清 <code>this</code>工作机制并且当有bug的时候能够找出错误所在。
幸运的是，TypeScript能通知你错误地使用了 <code>this</code>的地方。</p> <h3 id="this和箭头函数">this和箭头函数</h3> <p>JavaScript里，<code>this</code>的值在函数被调用的时候才会指定。
这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。
但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。</p> <p>下面看一个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> deck <span class="token operator">=</span> <span class="token punctuation">{</span>
    suits<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;hearts&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;spades&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;clubs&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;diamonds&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    cards<span class="token punctuation">:</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">52</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function-variable function">createCardPicker</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> pickedCard <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">52</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">let</span> pickedSuit <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>pickedCard <span class="token operator">/</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">return</span> <span class="token punctuation">{</span>suit<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>suits<span class="token punctuation">[</span>pickedSuit<span class="token punctuation">]</span><span class="token punctuation">,</span> card<span class="token punctuation">:</span> pickedCard <span class="token operator">%</span> <span class="token number">13</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> cardPicker <span class="token operator">=</span> deck<span class="token punctuation">.</span><span class="token function">createCardPicker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> pickedCard <span class="token operator">=</span> <span class="token function">cardPicker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;card: &quot;</span> <span class="token operator">+</span> pickedCard<span class="token punctuation">.</span>card <span class="token operator">+</span> <span class="token string">&quot; of &quot;</span> <span class="token operator">+</span> pickedCard<span class="token punctuation">.</span>suit<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>可以看到createCardPicker是个函数，并且它又返回了一个函数。
如果我们尝试运行这个程序，会发现它并没有弹出对话框而是报错了。
因为 createCardPicker返回的函数里的this被设置成了window而不是deck对象。 因为我们只是独立的调用了 cardPicker()。
顶级的非方法式调用会将 <code>this</code>视为<code>window</code>。</p> <div class="tip custom-block"><p>在严格模式下， this为undefined而不是window。</p></div> <p>为了解决这个问题，我们可以在函数被返回时就绑好正确的this。 这样的话，无论之后怎么使用它，都会引用绑定的‘deck’对象。 我们需要改变函数表达式来使用ECMAScript 6箭头语法。
箭头函数能保存函数创建时的 this值，而不是调用时的值：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> deck <span class="token operator">=</span> <span class="token punctuation">{</span>
    suits<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;hearts&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;spades&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;clubs&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;diamonds&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    cards<span class="token punctuation">:</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">52</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function-variable function">createCardPicker</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// NOTE: the line below is now an arrow function, allowing us to capture 'this' right here</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> pickedCard <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">52</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">let</span> pickedSuit <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>pickedCard <span class="token operator">/</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">return</span> <span class="token punctuation">{</span>suit<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>suits<span class="token punctuation">[</span>pickedSuit<span class="token punctuation">]</span><span class="token punctuation">,</span> card<span class="token punctuation">:</span> pickedCard <span class="token operator">%</span> <span class="token number">13</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> cardPicker <span class="token operator">=</span> deck<span class="token punctuation">.</span><span class="token function">createCardPicker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> pickedCard <span class="token operator">=</span> <span class="token function">cardPicker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;card: &quot;</span> <span class="token operator">+</span> pickedCard<span class="token punctuation">.</span>card <span class="token operator">+</span> <span class="token string">&quot; of &quot;</span> <span class="token operator">+</span> pickedCard<span class="token punctuation">.</span>suit<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>更好事情是，TypeScript会警告你犯了一个错误，如果你给编译器设置了<code>--noImplicitThis</code>标记。
它会指出 <code>this.suits[pickedSuit]</code>里的this的类型为<code>any</code>。</p> <h3 id="this参数">this参数</h3> <p>不幸的是，<code>this.suits[pickedSuit]</code>的类型依旧为<code>any</code>。
这是因为 this来自对象字面量里的函数表达式。
修改的方法是，提供一个显式的 <code>this</code>参数。
<code>this</code>参数是个假的参数，它出现在参数列表的最前面：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">this</span><span class="token punctuation">:</span> <span class="token keyword">void</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// make sure `this` is unusable in this standalone function</span>
<span class="token punctuation">}</span>
</code></pre></div><p>让我们往例子里添加一些接口，Card 和 Deck，让类型重用能够变得清晰简单些：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">Card</span> <span class="token punctuation">{</span>
    suit<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
    card<span class="token punctuation">:</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">Deck</span> <span class="token punctuation">{</span>
    suits<span class="token punctuation">:</span> string<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    cards<span class="token punctuation">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">createCardPicker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">:</span> Deck<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Card<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> deck<span class="token punctuation">:</span> Deck <span class="token operator">=</span> <span class="token punctuation">{</span>
    suits<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;hearts&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;spades&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;clubs&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;diamonds&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    cards<span class="token punctuation">:</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">52</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">// NOTE: The function now explicitly specifies that its callee must be of type Deck</span>
    <span class="token function-variable function">createCardPicker</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">this</span><span class="token punctuation">:</span> Deck</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> pickedCard <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">52</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">let</span> pickedSuit <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>pickedCard <span class="token operator">/</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">return</span> <span class="token punctuation">{</span>suit<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>suits<span class="token punctuation">[</span>pickedSuit<span class="token punctuation">]</span><span class="token punctuation">,</span> card<span class="token punctuation">:</span> pickedCard <span class="token operator">%</span> <span class="token number">13</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> cardPicker <span class="token operator">=</span> deck<span class="token punctuation">.</span><span class="token function">createCardPicker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> pickedCard <span class="token operator">=</span> <span class="token function">cardPicker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;card: &quot;</span> <span class="token operator">+</span> pickedCard<span class="token punctuation">.</span>card <span class="token operator">+</span> <span class="token string">&quot; of &quot;</span> <span class="token operator">+</span> pickedCard<span class="token punctuation">.</span>suit<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>现在TypeScript知道createCardPicker期望在某个Deck对象上调用。
也就是说 <code>this</code>是Deck类型的，而非any，因此<code>--noImplicitThis</code>不会报错了。</p> <h3 id="this参数在回调函数里">this参数在回调函数里</h3> <p>你可以也看到过在回调函数里的<code>this</code>报错，当你将一个函数传递到某个库函数里稍后会被调用时。
因为当回调被调用的时候，它们会被当成一个普通函数调用， <code>this</code>将为undefined。
稍做改动，你就可以通过 <code>this</code>参数来避免错误。
首先，库函数的作者要指定 <code>this</code>的类型：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">UIElement</span> <span class="token punctuation">{</span>
    <span class="token function">addClickListener</span><span class="token punctuation">(</span><span class="token function-variable function">onclick</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">this</span><span class="token punctuation">:</span> <span class="token keyword">void</span><span class="token punctuation">,</span> e<span class="token punctuation">:</span> Event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">this</span><span class="token punctuation">:</span> <span class="token keyword">void</span> means that addClickListener expects onclick to be a <span class="token keyword">function</span> that does not require a <span class="token keyword">this</span> type<span class="token punctuation">.</span> Second<span class="token punctuation">,</span> annotate your calling code <span class="token keyword">with</span> <span class="token keyword">this</span><span class="token punctuation">:</span>

<span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>
    info<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
    <span class="token function">onClickBad</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">this</span><span class="token punctuation">:</span> Handler<span class="token punctuation">,</span> e<span class="token punctuation">:</span> Event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// oops, used this here. using this callback would crash at runtime</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>info <span class="token operator">=</span> e<span class="token punctuation">.</span>message<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> h <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
uiElement<span class="token punctuation">.</span><span class="token function">addClickListener</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>onClickBad<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error!</span>
</code></pre></div><p>指定了<code>this</code>类型后，你显式声明<code>onClickBad</code>必须在<code>Handler</code>的实例上调用。
然后TypeScript会检测到 <code>addClickListener</code>要求函数带有<code>this: void</code>。 改变 <code>this</code>类型来修复这个错误：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>
    info<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
    <span class="token function">onClickGood</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">this</span><span class="token punctuation">:</span> <span class="token keyword">void</span><span class="token punctuation">,</span> e<span class="token punctuation">:</span> Event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// can't use this here because it's of type void!</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'clicked!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> h <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
uiElement<span class="token punctuation">.</span><span class="token function">addClickListener</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>onClickGood<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>因为onClickGood指定了<code>this</code>类型为<code>void</code>，因此传递addClickListener是合法的。
当然了，这也意味着不能使用 <code>this.info</code>. 如果你两者都想要，你不得不使用箭头函数了：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>
    info<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
    <span class="token function-variable function">onClickGood</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e<span class="token punctuation">:</span> Event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>info <span class="token operator">=</span> e<span class="token punctuation">.</span>message <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这是可行的因为箭头函数不会捕获<code>this</code>，所以你总是可以把它们传给期望<code>this: void</code>的函数。
缺点是每个 Handler对象都会创建一个箭头函数。
另一方面，方法只会被创建一次，添加到 Handler的原型链上。 它们在不同 Handler对象间是共享的。</p> <h3 id="重载">重载</h3> <p>JavaScript本身是个动态语言。
JavaScript里函数根据传入不同的参数而返回不同类型的数据是很常见的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> suits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;hearts&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;spades&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;clubs&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;diamonds&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">pickCard</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">:</span> any <span class="token punctuation">{</span>
    <span class="token comment">// Check to see if we're working with an object/array</span>
    <span class="token comment">// if so, they gave us the deck and we'll pick the card</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">==</span> <span class="token string">&quot;object&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> pickedCard <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> x<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> pickedCard<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// Otherwise just let them pick the card</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">==</span> <span class="token string">&quot;number&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> pickedSuit <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>x <span class="token operator">/</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span> suit<span class="token punctuation">:</span> suits<span class="token punctuation">[</span>pickedSuit<span class="token punctuation">]</span><span class="token punctuation">,</span> card<span class="token punctuation">:</span> x <span class="token operator">%</span> <span class="token number">13</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> myDeck <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> suit<span class="token punctuation">:</span> <span class="token string">&quot;diamonds&quot;</span><span class="token punctuation">,</span> card<span class="token punctuation">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> suit<span class="token punctuation">:</span> <span class="token string">&quot;spades&quot;</span><span class="token punctuation">,</span> card<span class="token punctuation">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> suit<span class="token punctuation">:</span> <span class="token string">&quot;hearts&quot;</span><span class="token punctuation">,</span> card<span class="token punctuation">:</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> pickedCard1 <span class="token operator">=</span> myDeck<span class="token punctuation">[</span><span class="token function">pickCard</span><span class="token punctuation">(</span>myDeck<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;card: &quot;</span> <span class="token operator">+</span> pickedCard1<span class="token punctuation">.</span>card <span class="token operator">+</span> <span class="token string">&quot; of &quot;</span> <span class="token operator">+</span> pickedCard1<span class="token punctuation">.</span>suit<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> pickedCard2 <span class="token operator">=</span> <span class="token function">pickCard</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;card: &quot;</span> <span class="token operator">+</span> pickedCard2<span class="token punctuation">.</span>card <span class="token operator">+</span> <span class="token string">&quot; of &quot;</span> <span class="token operator">+</span> pickedCard2<span class="token punctuation">.</span>suit<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>pickCard方法根据传入参数的不同会返回两种不同的类型。
如果传入的是代表纸牌的对象，函数作用是从中抓一张牌。
如果用户想抓牌，我们告诉他抓到了什么牌。 但是这怎么在类型系统里表示呢。</p> <p>方法是为同一个函数提供多个函数类型定义来进行函数重载。
编译器会根据这个列表去处理函数的调用。</p> <p>下面我们来重载 pickCard函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> suits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;hearts&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;spades&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;clubs&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;diamonds&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">pickCard</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">:</span> <span class="token punctuation">{</span>suit<span class="token punctuation">:</span> string<span class="token punctuation">;</span> card<span class="token punctuation">:</span> number<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span><span class="token punctuation">:</span> number<span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">pickCard</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">:</span> number</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>suit<span class="token punctuation">:</span> string<span class="token punctuation">;</span> card<span class="token punctuation">:</span> number<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">pickCard</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">:</span> any <span class="token punctuation">{</span>
    <span class="token comment">// Check to see if we're working with an object/array</span>
    <span class="token comment">// if so, they gave us the deck and we'll pick the card</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">==</span> <span class="token string">&quot;object&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> pickedCard <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> x<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> pickedCard<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// Otherwise just let them pick the card</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">==</span> <span class="token string">&quot;number&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> pickedSuit <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>x <span class="token operator">/</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span> suit<span class="token punctuation">:</span> suits<span class="token punctuation">[</span>pickedSuit<span class="token punctuation">]</span><span class="token punctuation">,</span> card<span class="token punctuation">:</span> x <span class="token operator">%</span> <span class="token number">13</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> myDeck <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> suit<span class="token punctuation">:</span> <span class="token string">&quot;diamonds&quot;</span><span class="token punctuation">,</span> card<span class="token punctuation">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> suit<span class="token punctuation">:</span> <span class="token string">&quot;spades&quot;</span><span class="token punctuation">,</span> card<span class="token punctuation">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> suit<span class="token punctuation">:</span> <span class="token string">&quot;hearts&quot;</span><span class="token punctuation">,</span> card<span class="token punctuation">:</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> pickedCard1 <span class="token operator">=</span> myDeck<span class="token punctuation">[</span><span class="token function">pickCard</span><span class="token punctuation">(</span>myDeck<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;card: &quot;</span> <span class="token operator">+</span> pickedCard1<span class="token punctuation">.</span>card <span class="token operator">+</span> <span class="token string">&quot; of &quot;</span> <span class="token operator">+</span> pickedCard1<span class="token punctuation">.</span>suit<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> pickedCard2 <span class="token operator">=</span> <span class="token function">pickCard</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;card: &quot;</span> <span class="token operator">+</span> pickedCard2<span class="token punctuation">.</span>card <span class="token operator">+</span> <span class="token string">&quot; of &quot;</span> <span class="token operator">+</span> pickedCard2<span class="token punctuation">.</span>suit<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这样改变后，重载的pickCard函数在调用的时候会进行正确的类型检查。</p> <p>为了让编译器能够选择正确的检查类型，它与JavaScript里的处理流程相似。
它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。
因此，在定义重载的时候，一定要把最精确的定义放在最前面。</p> <p>注意，<code>function pickCard(x): any</code>并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象另一个接收数字。 以其它参数调用 pickCard会产生错误。</p> <h2 id="泛型-2">泛型</h2> <p>软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。
组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p> <p>在像C#和Java这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。
这样用户就可以以自己的数据类型来使用组件。</p> <h3 id="泛型之hello-world">泛型之Hello World</h3> <p>下面来创建第一个使用泛型的例子：identity函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是 echo命令。</p> <p>不用泛型的话，这个函数可能是下面这样：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">identity</span><span class="token punctuation">(</span><span class="token parameter">arg<span class="token punctuation">:</span> number</span><span class="token punctuation">)</span><span class="token punctuation">:</span> number <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>或者，我们使用any类型来定义函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">identity</span><span class="token punctuation">(</span><span class="token parameter">arg<span class="token punctuation">:</span> any</span><span class="token punctuation">)</span><span class="token punctuation">:</span> any <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用any类型会导致这个函数可以接收任何类型的arg参数，这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。
如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。</p> <p>因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。 这里，我们使用了 类型变量，它是一种特殊的变量，只用于表示类型而不是值。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> identity<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们给identity添加了类型变量T。 T帮助我们捕获用户传入的类型（比如：number），之后我们就可以使用这个类型。
之后我们再次使用了 T当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。
这允许我们跟踪函数里使用的类型的信息。</p> <p>我们把这个版本的identity函数叫做泛型，因为它可以适用于多个类型。
不同于使用 any，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。</p> <p>我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> output <span class="token operator">=</span> identity<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token string">&quot;myString&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// type of output will be 'string'</span>
</code></pre></div><p>这里我们明确的指定了T是string类型，并做为一个参数传给函数，使用了<code>&lt;&gt;</code>括起来而不是()。</p> <p>第二种方法更普遍。利用了类型推论 -- 即编译器会根据传入的参数自动地帮助我们确定T的类型：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> output <span class="token operator">=</span> <span class="token function">identity</span><span class="token punctuation">(</span><span class="token string">&quot;myString&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// type of output will be 'string'</span>
</code></pre></div><p>注意我们没必要使用尖括号（<code>&lt;&gt;</code>）来明确地传入类型；编译器可以查看<code>myString</code>的值，然后把T设置为它的类型。
类型推论帮助我们保持代码精简和高可读性。
如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入T的类型，在一些复杂的情况下，这是可能出现的。</p> <h3 id="使用泛型变量">使用泛型变量</h3> <p>使用泛型创建像identity这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。</p> <p>看下之前identity例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> identity<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果我们想同时打印出arg的长度。 我们很可能会这样做：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> loggingIdentity<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Error: T doesn't have .length</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果这么做，编译器会报错说我们使用了arg的.length属性，但是没有地方指明arg具有这个属性。
记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有 .length属性的。</p> <p>现在假设我们想操作T类型的数组而不直接是T。由于我们操作的是数组，所以.length属性是应该存在的。 我们可以像创建其它数组一样创建这个数组：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> loggingIdentity<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Array has a .length, so no more error</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>你可以这样理解loggingIdentity的类型：泛型函数loggingIdentity，接收类型参数T和参数arg，它是个元素类型是T的数组，并返回元素类型是T的数组。
如果我们传入数字数组，将返回一个数字数组，因为此时 T的的类型为number。
这可以让我们把泛型变量T当做类型的一部分使用，而不是整个类型，增加了灵活性。</p> <p>我们也可以这样实现上面的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> loggingIdentity<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> Array<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Array<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Array has a .length, so no more error</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用过其它语言的话，你可能对这种语法已经很熟悉了。 在下一节，会介绍如何创建自定义泛型像 Array<T>一样。</T></p> <h3 id="泛型类型">泛型类型</h3> <p>上一节，我们创建了identity通用函数，可以适用于不同的类型。 在这节，我们研究一下函数本身的类型，以及如何创建泛型接口。</p> <p>泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> identity<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> myIdentity<span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token parameter">arg<span class="token punctuation">:</span> <span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span> <span class="token operator">=</span> identity<span class="token punctuation">;</span>
</code></pre></div><p>我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> identity<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> myIdentity<span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token constant">U</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token parameter">arg<span class="token punctuation">:</span> <span class="token constant">U</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">U</span> <span class="token operator">=</span> identity<span class="token punctuation">;</span>
</code></pre></div><p>我们还可以使用带有调用签名的对象字面量来定义泛型函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> identity<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> myIdentity<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">}</span> <span class="token operator">=</span> identity<span class="token punctuation">;</span>
</code></pre></div><p>这引导我们去写第一个泛型接口了。 我们把上面例子里的对象字面量拿出来做为一个接口：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">GenericIdentityFn</span> <span class="token punctuation">{</span>
    <span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> identity<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> myIdentity<span class="token punctuation">:</span> GenericIdentityFn <span class="token operator">=</span> identity<span class="token punctuation">;</span>
</code></pre></div><p>一个相似的例子，我们可能想把泛型参数当作整个接口的一个参数。
这样我们就能清楚的知道使用的具体是哪个泛型类型（比如： <code>Dictionary&lt;string&gt;</code>而不只是Dictionary）。
这样接口里的其它成员也能知道这个参数的类型了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">GenericIdentityFn</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span>arg<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> identity<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> myIdentity<span class="token punctuation">:</span> GenericIdentityFn<span class="token operator">&lt;</span>number<span class="token operator">&gt;</span> <span class="token operator">=</span> identity<span class="token punctuation">;</span>
</code></pre></div><p>注意，我们的示例做了少许改动。
不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。
当我们使用 GenericIdentityFn的时候，还得传入一个类型参数来指定泛型类型（这里是：number），锁定了之后代码里使用的类型。
对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。</p> <p>除了泛型接口，我们还可以创建泛型类。</p> <div class="tip custom-block"><p class="custom-block-title">注意</p> <p>无法创建泛型枚举和泛型命名空间。</p></div> <h3 id="泛型类">泛型类</h3> <p>泛型类看上去与泛型接口差不多。 泛型类使用（ &lt;&gt;）括起泛型类型，跟在类名后面。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">GenericNumber</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    zeroValue<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
    <span class="token function-variable function">add</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> myGenericNumber <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GenericNumber</span><span class="token operator">&lt;</span>number<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
myGenericNumber<span class="token punctuation">.</span>zeroValue <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
myGenericNumber<span class="token punctuation">.</span><span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>GenericNumber类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用number类型。
也可以使用字符串或其它更复杂的类型。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> stringNumeric <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GenericNumber</span><span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
stringNumeric<span class="token punctuation">.</span>zeroValue <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
stringNumeric<span class="token punctuation">.</span><span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stringNumeric<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>stringNumeric<span class="token punctuation">.</span>zeroValue<span class="token punctuation">,</span> <span class="token string">&quot;test&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。</p> <p>我们在类那节说过，类有两部分：</p> <ul><li>静态部分</li> <li>实例部分。</li></ul> <div class="tip custom-block"><p class="custom-block-title">注意</p> <p>泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。</p></div> <h3 id="泛型约束">泛型约束</h3> <p>你应该会记得之前的一个例子，我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。
在 loggingIdentity例子中，我们想访问arg的length属性，但是编译器并不能证明每种类型都有length属性，所以就报错了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> loggingIdentity<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Error: T doesn't have .length</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>相比于操作any所有类型，我们想要限制函数去处理任意带有.length属性的所有类型。
只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。
为此，我们需要列出对于T的约束要求。</p> <p>为此，我们定义一个接口来描述约束条件。
创建一个包含 .length属性的接口，使用这个接口和extends关键字来实现约束：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">Lengthwise</span> <span class="token punctuation">{</span>
    length<span class="token punctuation">:</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> loggingIdentity<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">Lengthwise</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Now we know it has a .length property, so no more error</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">loggingIdentity</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Error, number doesn't have a .length property</span>
</code></pre></div><p>我们需要传入符合约束类型的值，必须包含必须的属性：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">loggingIdentity</span><span class="token punctuation">(</span><span class="token punctuation">{</span>length<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="在泛型约束中使用类型参数">在泛型约束中使用类型参数</h3> <p>你可以声明一个类型参数，且它被另一个类型参数所约束。
比如，现在我们想要用属性名从对象里获取这个属性。
并且我们想要确保这个属性存在于对象 obj上，因此我们需要在这两个类型之间使用约束。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> key<span class="token punctuation">:</span> <span class="token constant">K</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> c<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> d<span class="token punctuation">:</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">getProperty</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// okay</span>
<span class="token function">getProperty</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token string">&quot;m&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'.</span>
</code></pre></div><h3 id="在泛型里使用类类型">在泛型里使用类类型</h3> <p>在TypeScript使用泛型创建工厂函数时，需要引用构造函数的类类型。比如，</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> create<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>c<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>一个更高级的例子，使用原型属性推断并约束构造函数与类实例的关系。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">BeeKeeper</span> <span class="token punctuation">{</span>
    hasMask<span class="token punctuation">:</span> boolean<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">ZooKeeper</span> <span class="token punctuation">{</span>
    nametag<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    numLegs<span class="token punctuation">:</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Bee</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    keeper<span class="token punctuation">:</span> BeeKeeper<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Lion</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    keeper<span class="token punctuation">:</span> ZooKeeper<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> createInstance<span class="token operator">&lt;</span><span class="token constant">A</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>c<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">A</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token constant">A</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">createInstance</span><span class="token punctuation">(</span>Lion<span class="token punctuation">)</span><span class="token punctuation">.</span>keeper<span class="token punctuation">.</span>nametag<span class="token punctuation">;</span>  <span class="token comment">// typechecks!</span>
<span class="token function">createInstance</span><span class="token punctuation">(</span>Bee<span class="token punctuation">)</span><span class="token punctuation">.</span>keeper<span class="token punctuation">.</span>hasMask<span class="token punctuation">;</span>   <span class="token comment">// typechecks!</span>
</code></pre></div><h2 id="枚举-2">枚举</h2> <p>使用枚举我们可以定义一些带名字的常量。
使用枚举可以清晰地表达意图或创建一组有区别的用例。
TypeScript支持数字的和基于字符串的枚举。</p> <h3 id="数字枚举">数字枚举</h3> <p>首先我们看看数字枚举，如果你使用过其它编程语言应该会很熟悉。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">enum</span> Direction <span class="token punctuation">{</span>
    Up <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
    Down<span class="token punctuation">,</span>
    Left<span class="token punctuation">,</span>
    Right
<span class="token punctuation">}</span>
</code></pre></div><p>如上，我们定义了一个数字枚举， Up使用初始化为 1。 其余的成员会从 1开始自动增长。 换句话说， Direction.Up的值为 1， Down为 2， Left为 3， Right为 4。</p> <p>我们还可以完全不使用初始化器：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">enum</span> Direction <span class="token punctuation">{</span>
    Up<span class="token punctuation">,</span>
    Down<span class="token punctuation">,</span>
    Left<span class="token punctuation">,</span>
    Right<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在， Up的值为 0， Down的值为 1等等。 当我们不在乎成员的值的时候，这种自增长的行为是很有用处的，但是要注意每个枚举成员的值都是不同的。</p> <p>使用枚举很简单：通过枚举的属性来访问枚举成员，和枚举的名字来访问枚举类型：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">enum</span> Response <span class="token punctuation">{</span>
    No <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    Yes <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">respond</span><span class="token punctuation">(</span><span class="token parameter">recipient<span class="token punctuation">:</span> string<span class="token punctuation">,</span> message<span class="token punctuation">:</span> Response</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token function">respond</span><span class="token punctuation">(</span><span class="token string">&quot;Princess Caroline&quot;</span><span class="token punctuation">,</span> Response<span class="token punctuation">.</span>Yes<span class="token punctuation">)</span>
</code></pre></div><p>数字枚举可以被混入到 计算过的和常量成员（如下所示）。
简短地说，不带初始化器的枚举或者被放在第一的位置，或者被放在使用了数字常量或其它常量初始化了的枚举后面。
换句话说，下面的情况是不被允许的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">enum</span> <span class="token constant">E</span> <span class="token punctuation">{</span>
    <span class="token constant">A</span> <span class="token operator">=</span> <span class="token function">getSomeValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token constant">B</span><span class="token punctuation">,</span> <span class="token comment">// error! 'A' is not constant-initialized, so 'B' needs an initializer</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="字符串枚举">字符串枚举</h3> <p>字符串枚举的概念很简单，但是有细微的 运行时的差别。
在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">enum</span> Direction <span class="token punctuation">{</span>
    Up <span class="token operator">=</span> <span class="token string">&quot;UP&quot;</span><span class="token punctuation">,</span>
    Down <span class="token operator">=</span> <span class="token string">&quot;DOWN&quot;</span><span class="token punctuation">,</span>
    Left <span class="token operator">=</span> <span class="token string">&quot;LEFT&quot;</span><span class="token punctuation">,</span>
    Right <span class="token operator">=</span> <span class="token string">&quot;RIGHT&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。
换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息（尽管 反向映射会有所帮助），
字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。</p> <h3 id="异构枚举（heterogeneous-enums）">异构枚举（Heterogeneous enums）</h3> <p>从技术的角度来说，枚举可以混合字符串和数字成员，但是似乎你并不会这么做：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">enum</span> BooleanLikeHeterogeneousEnum <span class="token punctuation">{</span>
    No <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    Yes <span class="token operator">=</span> <span class="token string">&quot;YES&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>除非你真的想要利用JavaScript运行时的行为，否则我们不建议这样做。</p> <h3 id="计算的和常量成员">计算的和常量成员</h3> <p>每个枚举成员都带有一个值，它可以是 常量或 计算出来的。 当满足如下条件时，枚举成员被当作是常量：</p> <p>它是枚举的第一个成员且没有初始化器，这种情况下它被赋予值 0：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// E.X is constant:</span>
<span class="token keyword">enum</span> <span class="token constant">E</span> <span class="token punctuation">{</span> <span class="token constant">X</span> <span class="token punctuation">}</span>
</code></pre></div><p>它不带有初始化器且它之前的枚举成员是一个 数字常量。 这种情况下，当前枚举成员的值为它上一个枚举成员的值加1。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// All enum members in 'E1' and 'E2' are constant.</span>

<span class="token keyword">enum</span> <span class="token constant">E1</span> <span class="token punctuation">{</span> <span class="token constant">X</span><span class="token punctuation">,</span> <span class="token constant">Y</span><span class="token punctuation">,</span> <span class="token constant">Z</span> <span class="token punctuation">}</span>

<span class="token keyword">enum</span> <span class="token constant">E2</span> <span class="token punctuation">{</span>
    <span class="token constant">A</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">C</span>
<span class="token punctuation">}</span>
</code></pre></div><p>枚举成员使用 常量枚举表达式初始化。
常数枚举表达式是TypeScript表达式的子集，它可以在编译阶段求值。
当一个表达式满足下面条件之一时，它就是一个常量枚举表达式：</p> <ul><li>一个枚举表达式字面量（主要是字符串字面量或数字字面量）</li> <li>一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的）</li> <li>带括号的常量枚举表达式</li> <li>一元运算符 +, -, ~其中之一应用在了常量枚举表达式</li> <li>常量枚举表达式做为二元运算符 +, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^的操作对象。 若常数枚举表达式求值后为 NaN或 Infinity，则会在编译阶段报错。</li> <li>所有其它情况的枚举成员被当作是需要计算得出的值。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">enum</span> FileAccess <span class="token punctuation">{</span>
    <span class="token comment">// constant members</span>
    None<span class="token punctuation">,</span>
    Read    <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span>
    Write   <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">,</span>
    ReadWrite  <span class="token operator">=</span> Read <span class="token operator">|</span> Write<span class="token punctuation">,</span>
    <span class="token comment">// computed member</span>
    <span class="token constant">G</span> <span class="token operator">=</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">.</span>length
<span class="token punctuation">}</span>
</code></pre></div><h3 id="联合枚举与枚举成员的类型">联合枚举与枚举成员的类型</h3> <p>存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。
字面量枚举成员是指不带有初始值的常量枚举成员，或者是值被初始化为</p> <ul><li>任何字符串字面量（例如： &quot;foo&quot;， &quot;bar&quot;， &quot;baz&quot;）</li> <li>任何数字字面量（例如： 1, 100）</li> <li>应用了一元 -符号的数字字面量（例如： -1, -100）</li> <li>当所有枚举成员都拥有字面量枚举值时，它就带有了一种特殊的语义。</li></ul> <p>首先，枚举成员成为了类型！ 例如，我们可以说某些成员 只能是枚举成员的值：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">enum</span> ShapeKind <span class="token punctuation">{</span>
    Circle<span class="token punctuation">,</span>
    Square<span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Circle</span> <span class="token punctuation">{</span>
    kind<span class="token punctuation">:</span> ShapeKind<span class="token punctuation">.</span>Circle<span class="token punctuation">;</span>
    radius<span class="token punctuation">:</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Square</span> <span class="token punctuation">{</span>
    kind<span class="token punctuation">:</span> ShapeKind<span class="token punctuation">.</span>Square<span class="token punctuation">;</span>
    sideLength<span class="token punctuation">:</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> c<span class="token punctuation">:</span> Circle <span class="token operator">=</span> <span class="token punctuation">{</span>
    kind<span class="token punctuation">:</span> ShapeKind<span class="token punctuation">.</span>Square<span class="token punctuation">,</span>
    <span class="token comment">//    ~~~~~~~~~~~~~~~~ Error!</span>
    radius<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>另一个变化是枚举类型本身变成了每个枚举成员的 联合。
虽然我们还没有讨论联合类型，但你只要知道通过联合枚举，类型系统能够利用这样一个事实，它可以知道枚举里的值的集合。
因此，TypeScript能够捕获在比较值的时候犯的愚蠢的错误。 例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">enum</span> <span class="token constant">E</span> <span class="token punctuation">{</span>
    Foo<span class="token punctuation">,</span>
    Bar<span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">:</span> <span class="token constant">E</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!==</span> <span class="token constant">E</span><span class="token punctuation">.</span>Foo <span class="token operator">||</span> x <span class="token operator">!==</span> <span class="token constant">E</span><span class="token punctuation">.</span>Bar<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//             ~~~~~~~~~~~</span>
        <span class="token comment">// Error! Operator '!==' cannot be applied to types 'E.Foo' and 'E.Bar'.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个例子里，我们先检查 x是否不是 E.Foo。 如果通过了这个检查，然后 ||会发生短路效果， if语句体里的内容会被执行。
然而，这个检查没有通过，那么 x则 只能为 E.Foo，因此没理由再去检查它是否为 E.Bar。</p> <h3 id="运行时的枚举">运行时的枚举</h3> <p>枚举是在运行时真正存在的对象。 例如下面的枚举：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">enum</span> <span class="token constant">E</span> <span class="token punctuation">{</span>
    <span class="token constant">X</span><span class="token punctuation">,</span> <span class="token constant">Y</span><span class="token punctuation">,</span> <span class="token constant">Z</span>
<span class="token punctuation">}</span>
<span class="token comment">// can actually be passed around to functions</span>

<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token constant">X</span><span class="token punctuation">:</span> number <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">.</span><span class="token constant">X</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Works, since 'E' has a property named 'X' which is a number.</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token constant">E</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="反向映射">反向映射</h3> <div class="tip custom-block"><p>除了创建一个以属性名做为对象成员的对象之外，数字枚举成员还具有了 反向映射，从枚举值到枚举名字。</p></div> <p>例如，在下面的例子中：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">enum</span> Enum <span class="token punctuation">{</span>
    <span class="token constant">A</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> Enum<span class="token punctuation">.</span><span class="token constant">A</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> nameOfA <span class="token operator">=</span> Enum<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// &quot;A&quot;</span>
</code></pre></div><p>TypeScript可能会将这段代码编译为下面的JavaScript：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> Enum<span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">Enum</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Enum<span class="token punctuation">[</span>Enum<span class="token punctuation">[</span><span class="token string">&quot;A&quot;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;A&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Enum <span class="token operator">||</span> <span class="token punctuation">(</span>Enum <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> Enum<span class="token punctuation">.</span><span class="token constant">A</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> nameOfA <span class="token operator">=</span> Enum<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// &quot;A&quot;</span>
</code></pre></div><p>生成的代码中，枚举类型被编译成一个对象，它包含了正向映射<code>（ name -&gt; value）</code>和反向映射<code>（ value -&gt; name）</code>。
引用枚举成员总会生成为对属性访问并且永远也不会内联代码。</p> <p>要注意的是 不会为字符串枚举成员生成反向映射。</p> <h3 id="const枚举">const枚举</h3> <p>大多数情况下，枚举是十分有效的方案。 然而在某些情况下需求很严格。</p> <p>为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用 const枚举。
常量枚举通过在枚举上使用 const修饰符来定义。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token keyword">enum</span> Enum <span class="token punctuation">{</span>
    <span class="token constant">A</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token constant">B</span> <span class="token operator">=</span> <span class="token constant">A</span> <span class="token operator">*</span> <span class="token number">2</span>
<span class="token punctuation">}</span>
</code></pre></div><p>常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。
常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token keyword">enum</span> Directions <span class="token punctuation">{</span>
    Up<span class="token punctuation">,</span>
    Down<span class="token punctuation">,</span>
    Left<span class="token punctuation">,</span>
    Right
<span class="token punctuation">}</span>

<span class="token keyword">let</span> directions <span class="token operator">=</span> <span class="token punctuation">[</span>Directions<span class="token punctuation">.</span>Up<span class="token punctuation">,</span> Directions<span class="token punctuation">.</span>Down<span class="token punctuation">,</span> Directions<span class="token punctuation">.</span>Left<span class="token punctuation">,</span> Directions<span class="token punctuation">.</span>Right<span class="token punctuation">]</span>
</code></pre></div><p>生成后的代码为：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> directions <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token comment">/* Up */</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token comment">/* Down */</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token comment">/* Left */</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token comment">/* Right */</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="外部枚举">外部枚举</h3> <p>外部枚举用来描述已经存在的枚举类型的形状。</p> <div class="language-js extra-class"><pre class="language-js"><code>declare <span class="token keyword">enum</span> Enum <span class="token punctuation">{</span>
    <span class="token constant">A</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token constant">B</span><span class="token punctuation">,</span>
    <span class="token constant">C</span> <span class="token operator">=</span> <span class="token number">2</span>
<span class="token punctuation">}</span>
</code></pre></div><p>外部枚举和非外部枚举之间有一个重要的区别，在正常的枚举里，没有初始化方法的成员被当成常数成员。
对于非常数的外部枚举而言，没有初始化方法时被当做需要经过计算的。</p> <h2 id="装饰器">装饰器</h2> <p>随着TypeScript和ES6里引入了类，在一些场景下我们需要额外的特性来支持标注或修改类及其成员。
装饰器（Decorators）为我们在类的声明及成员上通过元编程语法添加标注提供了一种方式。
Javascript里的装饰器目前处在 建议征集的第二阶段，但在TypeScript里已做为一项实验性特性予以支持。</p> <div class="tip custom-block"><p>装饰器是一项实验性特性，在未来的版本中可能会发生改变。</p> <p>若要启用实验性的装饰器特性，你必须在命令行或<code>tsconfig.json</code>里启用<code>experimentalDecorators</code>编译器选项：</p> <p>命令行:</p> <div class="language- extra-class"><pre class="language-text"><code>tsc --target ES5 --experimentalDecorators
tsconfig.json:

{
    &quot;compilerOptions&quot;: {
        &quot;target&quot;: &quot;ES5&quot;,
        &quot;experimentalDecorators&quot;: true
    }
}
</code></pre></div></div> <h3 id="装饰器-2">装饰器</h3> <p>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。
装饰器使用 <code>@expression</code>这种形式，<code>expression</code>求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。</p> <p>例如，有一个@sealed装饰器，我们会这样定义sealed函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">sealed</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// do something with &quot;target&quot; ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意  后面类装饰器小节里有一个更加详细的例子。</p> <h3 id="装饰器工厂">装饰器工厂</h3> <p>如果我们要定制一个修饰器如何应用到一个声明上，我们得写一个装饰器工厂函数。
装饰器工厂就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。</p> <p>我们可以通过下面的方式来写一个装饰器工厂函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">color</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 这是一个装饰器工厂</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//  这是装饰器</span>
        <span class="token comment">// do something with &quot;target&quot; and &quot;value&quot;...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意  下面方法装饰器小节里有一个更加详细的例子。</p> <h3 id="装饰器组合">装饰器组合</h3> <p>多个装饰器可以同时应用到一个声明上，就像下面的示例：</p> <div class="language- extra-class"><pre class="language-text"><code>书写在同一行上：
@f @g x

书写在多行上：
@f
@g
x
</code></pre></div><p>当多个装饰器应用于一个声明上，它们求值方式与复合函数相似。
在这个模型下，当复合f和g时，复合的结果(f ∘ g)(x)等同于f(g(x))。</p> <div class="tip custom-block"><p class="custom-block-title">TypeScript 多个装饰器的应用规则</p> <p>在TypeScript里，当多个装饰器应用在一个声明上时会进行如下步骤的操作：
由上至下依次对装饰器表达式求值。
求值的结果会被当作函数，由下至上依次调用。</p></div> <p>如果我们使用装饰器工厂的话，可以通过下面的例子来观察它们求值的顺序：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;f(): evaluated&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> propertyKey<span class="token punctuation">:</span> string<span class="token punctuation">,</span> descriptor<span class="token punctuation">:</span> PropertyDescriptor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;f(): called&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;g(): evaluated&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> propertyKey<span class="token punctuation">:</span> string<span class="token punctuation">,</span> descriptor<span class="token punctuation">:</span> PropertyDescriptor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;g(): called&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
    @<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    @<span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在控制台里会打印出如下结果：</p> <div class="language- extra-class"><pre class="language-text"><code>f(): evaluated
g(): evaluated
g(): called
f(): called
</code></pre></div><h3 id="装饰器求值">装饰器求值</h3> <p>类中不同声明上的装饰器将按以下规定的顺序应用：</p> <ul><li>参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个实例成员。</li> <li>参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个静态成员。</li> <li>参数装饰器应用到构造函数。</li> <li>类装饰器应用到类。</li></ul> <h3 id="类装饰器">类装饰器</h3> <div class="tip custom-block"><p>类装饰器在类声明之前被声明（紧靠着类声明）。
类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。
类装饰器不能用在声明文件中( .d.ts)，也不能用在任何外部上下文中（比如declare的类）。</p></div> <p>类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。</p> <p>如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。</p> <div class="tip custom-block"><p>如果你要返回一个新的构造函数，你必须注意处理好原来的原型链。 在运行时的装饰器调用逻辑中 不会为你做这些。</p></div> <p>下面是使用类装饰器(@sealed)的例子，应用在Greeter类：</p> <div class="language-js extra-class"><pre class="language-js"><code>@sealed
<span class="token keyword">class</span> <span class="token class-name">Greeter</span> <span class="token punctuation">{</span>
    greeting<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">message<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>greeting <span class="token operator">=</span> message<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;Hello, &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>greeting<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们可以这样定义@sealed装饰器：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">sealed</span><span class="token punctuation">(</span><span class="token parameter">constructor<span class="token punctuation">:</span> Function</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Object<span class="token punctuation">.</span><span class="token function">seal</span><span class="token punctuation">(</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Object<span class="token punctuation">.</span><span class="token function">seal</span><span class="token punctuation">(</span>constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当@sealed被执行的时候，它将密封此类的构造函数和原型。(注：参见Object.seal)</p> <p>下面是一个重载构造函数的例子。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> classDecorator<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">{</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">:</span>any<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>constructor<span class="token punctuation">:</span><span class="token constant">T</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> constructor <span class="token punctuation">{</span>
        newProperty <span class="token operator">=</span> <span class="token string">&quot;new property&quot;</span><span class="token punctuation">;</span>
        hello <span class="token operator">=</span> <span class="token string">&quot;override&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

@classDecorator
<span class="token keyword">class</span> <span class="token class-name">Greeter</span> <span class="token punctuation">{</span>
    property <span class="token operator">=</span> <span class="token string">&quot;property&quot;</span><span class="token punctuation">;</span>
    hello<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">m<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>hello <span class="token operator">=</span> m<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Greeter</span><span class="token punctuation">(</span><span class="token string">&quot;world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="方法装饰器">方法装饰器</h3> <div class="tip custom-block"><p>方法装饰器声明在一个方法的声明之前（紧靠着方法声明）。
它会被应用到方法的 属性描述符上，可以用来监视，修改或者替换方法定义。
方法装饰器不能用在声明文件( .d.ts)，重载或者任何外部上下文（比如declare的类）中。</p></div> <p>方法装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p> <ul><li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li> <li>成员的名字。</li> <li>成员的属性描述符。</li></ul> <div class="tip custom-block"><p class="custom-block-title">注意</p> <ul><li>如果代码输出目标版本小于ES5，属性描述符将会是undefined。</li> <li>如果方法装饰器返回一个值，它会被用作方法的属性描述符。</li> <li>如果代码输出目标版本小于ES5返回值会被忽略。</li></ul></div> <p>下面是一个方法装饰器（@enumerable）的例子，应用于Greeter类的方法上：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Greeter</span> <span class="token punctuation">{</span>
    greeting<span class="token punctuation">:</span> string<span class="token punctuation">;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">message<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>greeting <span class="token operator">=</span> message<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    @<span class="token function">enumerable</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
    <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;Hello, &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>greeting<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们可以用下面的函数声明来定义@enumerable装饰器：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">enumerable</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">:</span> boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">:</span> any<span class="token punctuation">,</span> propertyKey<span class="token punctuation">:</span> string<span class="token punctuation">,</span> descriptor<span class="token punctuation">:</span> PropertyDescriptor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        descriptor<span class="token punctuation">.</span>enumerable <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里的@enumerable(false)是一个装饰器工厂。 当装饰器 @enumerable(false)被调用时，它会修改属性描述符的enumerable属性。</p> <h3 id="访问器装饰器">访问器装饰器</h3> <p>访问器装饰器声明在一个访问器的声明之前（紧靠着访问器声明）。
访问器装饰器应用于访问器的 属性描述符并且可以用来监视，修改或替换一个访问器的定义。
访问器装饰器不能用在声明文件中（.d.ts），或者任何外部上下文（比如 declare的类）里。</p> <div class="tip custom-block"><p class="custom-block-title">注意</p> <p>TypeScript不允许同时装饰一个成员的get和set访问器。取而代之的是，一个成员的所有装饰的必须应用在文档顺序的第一个访问器上。
这是因为，在装饰器应用于一个属性描述符时，它联合了get和set访问器，而不是分开声明的。</p></div> <p>访问器装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p> <ul><li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li> <li>成员的名字。</li> <li>成员的属性描述符。</li></ul> <div class="tip custom-block"><p class="custom-block-title">注意</p> <ul><li>如果代码输出目标版本小于ES5，Property Descriptor将会是undefined。</li> <li>如果访问器装饰器返回一个值，它会被用作方法的属性描述符。</li> <li>如果代码输出目标版本小于ES5返回值会被忽略。</li></ul></div> <p>下面是使用了访问器装饰器（@configurable）的例子，应用于Point类的成员上：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> _x<span class="token punctuation">:</span> number<span class="token punctuation">;</span>
    <span class="token keyword">private</span> _y<span class="token punctuation">:</span> number<span class="token punctuation">;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">:</span> number<span class="token punctuation">,</span> y<span class="token punctuation">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_x <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_y <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    @<span class="token function">configurable</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
    <span class="token keyword">get</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_x<span class="token punctuation">;</span> <span class="token punctuation">}</span>

    @<span class="token function">configurable</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
    <span class="token keyword">get</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_y<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们可以通过如下函数声明来定义@configurable装饰器：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">configurable</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">:</span> boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">:</span> any<span class="token punctuation">,</span> propertyKey<span class="token punctuation">:</span> string<span class="token punctuation">,</span> descriptor<span class="token punctuation">:</span> PropertyDescriptor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        descriptor<span class="token punctuation">.</span>configurable <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="属性装饰器">属性装饰器</h3> <p>属性装饰器声明在一个属性声明之前（紧靠着属性声明）。
属性装饰器不能用在声明文件中（.d.ts），或者任何外部上下文（比如 declare的类）里。</p> <p>属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数：</p> <ul><li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li> <li>成员的名字。</li></ul> <div class="tip custom-block"><p class="custom-block-title">注意</p> <p>属性描述符不会做为参数传入属性装饰器，这与TypeScript是如何初始化属性装饰器的有关。
因为目前没有办法在定义一个原型对象的成员时描述一个实例属性，并且没办法监视或修改一个属性的初始化方法。
返回值也会被忽略。
因此，属性描述符只能用来监视类中是否声明了某个名字的属性。</p></div> <p>我们可以用它来记录这个属性的元数据，如下例所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Greeter</span> <span class="token punctuation">{</span>
    @<span class="token function">format</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, %s&quot;</span><span class="token punctuation">)</span>
    greeting<span class="token punctuation">:</span> string<span class="token punctuation">;</span>

    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">message<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>greeting <span class="token operator">=</span> message<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> formatString <span class="token operator">=</span> <span class="token function">getFormat</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">&quot;greeting&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> formatString<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">&quot;%s&quot;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>greeting<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后定义@format装饰器和getFormat函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token string">&quot;reflect-metadata&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> formatMetadataKey <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;format&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">format</span><span class="token punctuation">(</span><span class="token parameter">formatString<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">metadata</span><span class="token punctuation">(</span>formatMetadataKey<span class="token punctuation">,</span> formatString<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">getFormat</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">:</span> any<span class="token punctuation">,</span> propertyKey<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span>formatMetadataKey<span class="token punctuation">,</span> target<span class="token punctuation">,</span> propertyKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个<code>@format(&quot;Hello, %s&quot;)</code>装饰器是个 装饰器工厂。 当 <code>@format(&quot;Hello, %s&quot;)</code>被调用时，它添加一条这个属性的元数据，通过reflect-metadata库里的Reflect.metadata函数。
当 getFormat被调用时，它读取格式的元数据。</p> <div class="tip custom-block"><p class="custom-block-title">注意</p> <p>这个例子需要使用reflect-metadata库。 查看 元数据了解reflect-metadata库更详细的信息。</p></div> <h3 id="参数装饰器">参数装饰器</h3> <p>参数装饰器声明在一个参数声明之前（紧靠着参数声明）。
参数装饰器应用于类构造函数或方法声明。 参数装饰器不能用在声明文件（.d.ts），重载或其它外部上下文（比如 declare的类）里。</p> <p>参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p> <ul><li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li> <li>成员的名字。</li> <li>参数在函数参数列表中的索引。</li></ul> <div class="tip custom-block"><p class="custom-block-title">注意</p> <p>参数装饰器只能用来监视一个方法的参数是否被传入。</p> <p>参数装饰器的返回值会被忽略。</p></div> <p>下例定义了参数装饰器（@required）并应用于Greeter类方法的一个参数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Greeter</span> <span class="token punctuation">{</span>
    greeting<span class="token punctuation">:</span> string<span class="token punctuation">;</span>

    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">message<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>greeting <span class="token operator">=</span> message<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    @validate
    <span class="token function">greet</span><span class="token punctuation">(</span><span class="token parameter">@required name<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;Hello &quot;</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">&quot;, &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>greeting<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后我们使用下面的函数定义 @required 和 @validate 装饰器：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token string">&quot;reflect-metadata&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> requiredMetadataKey <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;required&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">required</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">:</span> Object<span class="token punctuation">,</span> propertyKey<span class="token punctuation">:</span> string <span class="token operator">|</span> symbol<span class="token punctuation">,</span> parameterIndex<span class="token punctuation">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> existingRequiredParameters<span class="token punctuation">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">getOwnMetadata</span><span class="token punctuation">(</span>requiredMetadataKey<span class="token punctuation">,</span> target<span class="token punctuation">,</span> propertyKey<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    existingRequiredParameters<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>parameterIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Reflect<span class="token punctuation">.</span><span class="token function">defineMetadata</span><span class="token punctuation">(</span>requiredMetadataKey<span class="token punctuation">,</span> existingRequiredParameters<span class="token punctuation">,</span> target<span class="token punctuation">,</span> propertyKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">validate</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">:</span> any<span class="token punctuation">,</span> propertyName<span class="token punctuation">:</span> string<span class="token punctuation">,</span> descriptor<span class="token punctuation">:</span> TypedPropertyDescriptor<span class="token operator">&lt;</span>Function<span class="token operator">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> method <span class="token operator">=</span> descriptor<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    descriptor<span class="token punctuation">.</span><span class="token function-variable function">value</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> requiredParameters<span class="token punctuation">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">getOwnMetadata</span><span class="token punctuation">(</span>requiredMetadataKey<span class="token punctuation">,</span> target<span class="token punctuation">,</span> propertyName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>requiredParameters<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> parameterIndex <span class="token keyword">of</span> requiredParameters<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>parameterIndex <span class="token operator">&gt;=</span> arguments<span class="token punctuation">.</span>length <span class="token operator">||</span> arguments<span class="token punctuation">[</span>parameterIndex<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Missing required argument.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> <span class="token function">method</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>@required装饰器添加了元数据实体把参数标记为必需的。 @validate装饰器把greet方法包裹在一个函数里在调用原先的函数前验证函数参数。</p> <p>注意  这个例子使用了reflect-metadata库。 查看 元数据了解reflect-metadata库的更多信息。</p> <h3 id="元数据">元数据</h3> <p>一些例子使用了reflect-metadata库来支持实验性的metadata API。
这个库还不是ECMAScript (JavaScript)标准的一部分。
然而，当装饰器被ECMAScript官方标准采纳后，这些扩展也将被推荐给ECMAScript以采纳。</p> <p>你可以通过npm安装这个库：</p> <div class="language- extra-class"><pre class="language-text"><code>npm i reflect-metadata --save
</code></pre></div><p>TypeScript支持为带有装饰器的声明生成元数据。
你需要在命令行或 tsconfig.json里启用emitDecoratorMetadata编译器选项。</p> <div class="language- extra-class"><pre class="language-text"><code>Command Line:

tsc --target ES5 --experimentalDecorators --emitDecoratorMetadata
tsconfig.json:

{
    &quot;compilerOptions&quot;: {
        &quot;target&quot;: &quot;ES5&quot;,
        &quot;experimentalDecorators&quot;: true,
        &quot;emitDecoratorMetadata&quot;: true
    }
}
</code></pre></div><p>当启用后，只要reflect-metadata库被引入了，设计阶段添加的类型信息可以在运行时使用。</p> <p>如下例所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token string">&quot;reflect-metadata&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">:</span> number<span class="token punctuation">;</span>
    y<span class="token punctuation">:</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Line</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> _p0<span class="token punctuation">:</span> Point<span class="token punctuation">;</span>
    <span class="token keyword">private</span> _p1<span class="token punctuation">:</span> Point<span class="token punctuation">;</span>

    @validate
    <span class="token keyword">set</span> <span class="token function">p0</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">:</span> Point</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_p0 <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">get</span> <span class="token function">p0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_p0<span class="token punctuation">;</span> <span class="token punctuation">}</span>

    @validate
    <span class="token keyword">set</span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">:</span> Point</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_p1 <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">get</span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_p1<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> validate<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>target<span class="token punctuation">:</span> any<span class="token punctuation">,</span> propertyKey<span class="token punctuation">:</span> string<span class="token punctuation">,</span> descriptor<span class="token punctuation">:</span> TypedPropertyDescriptor<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">set</span> <span class="token operator">=</span> descriptor<span class="token punctuation">.</span>set<span class="token punctuation">;</span>
    descriptor<span class="token punctuation">.</span><span class="token function-variable function">set</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">:</span> <span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> type <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token string">&quot;design:type&quot;</span><span class="token punctuation">,</span> target<span class="token punctuation">,</span> propertyKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name">type</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">&quot;Invalid type.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
TypeScript编译器可以通过@Reflect<span class="token punctuation">.</span>metadata装饰器注入设计阶段的类型信息。 你可以认为它相当于下面的TypeScript：

<span class="token keyword">class</span> <span class="token class-name">Line</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> _p0<span class="token punctuation">:</span> Point<span class="token punctuation">;</span>
    <span class="token keyword">private</span> _p1<span class="token punctuation">:</span> Point<span class="token punctuation">;</span>

    @validate
    @Reflect<span class="token punctuation">.</span><span class="token function">metadata</span><span class="token punctuation">(</span><span class="token string">&quot;design:type&quot;</span><span class="token punctuation">,</span> Point<span class="token punctuation">)</span>
    <span class="token keyword">set</span> <span class="token function">p0</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">:</span> Point</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_p0 <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">get</span> <span class="token function">p0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_p0<span class="token punctuation">;</span> <span class="token punctuation">}</span>

    @validate
    @Reflect<span class="token punctuation">.</span><span class="token function">metadata</span><span class="token punctuation">(</span><span class="token string">&quot;design:type&quot;</span><span class="token punctuation">,</span> Point<span class="token punctuation">)</span>
    <span class="token keyword">set</span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">:</span> Point</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_p1 <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">get</span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_p1<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">warning</p> <p>装饰器元数据是个实验性的特性并且可能在以后的版本中发生破坏性的改变（breaking changes）。</p></div> <h2 id="mixins">Mixins</h2> <p>除了传统的面向对象继承方式，还流行一种通过可重用组件创建类的方式，就是联合另一个简单类的代码。
你可能在Scala等语言里对mixins及其特性已经很熟悉了，但它在JavaScript中也是很流行的。</p> <h3 id="混入示例">混入示例</h3> <p>下面的代码演示了如何在TypeScript里使用混入。
后面我们还会解释这段代码是怎么工作的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Disposable Mixin</span>
<span class="token keyword">class</span> <span class="token class-name">Disposable</span> <span class="token punctuation">{</span>
    isDisposed<span class="token punctuation">:</span> boolean<span class="token punctuation">;</span>
    <span class="token function">dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>isDisposed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token comment">// Activatable Mixin</span>
<span class="token keyword">class</span> <span class="token class-name">Activatable</span> <span class="token punctuation">{</span>
    isActive<span class="token punctuation">:</span> boolean<span class="token punctuation">;</span>
    <span class="token function">activate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>isActive <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">deactivate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>isActive <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">SmartObject</span> <span class="token keyword">implements</span> <span class="token class-name">Disposable</span><span class="token punctuation">,</span> Activatable <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>isActive <span class="token operator">+</span> <span class="token string">&quot; : &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>isDisposed<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">interact</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">activate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Disposable</span>
    isDisposed<span class="token punctuation">:</span> boolean <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token function-variable function">dispose</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
    <span class="token comment">// Activatable</span>
    isActive<span class="token punctuation">:</span> boolean <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token function-variable function">activate</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
    <span class="token function-variable function">deactivate</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">applyMixins</span><span class="token punctuation">(</span>SmartObject<span class="token punctuation">,</span> <span class="token punctuation">[</span>Disposable<span class="token punctuation">,</span> Activatable<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> smartObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SmartObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> smartObj<span class="token punctuation">.</span><span class="token function">interact</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">////////////////////////////////////////</span>
<span class="token comment">// In your runtime library somewhere</span>
<span class="token comment">////////////////////////////////////////</span>

<span class="token keyword">function</span> <span class="token function">applyMixins</span><span class="token punctuation">(</span><span class="token parameter">derivedCtor<span class="token punctuation">:</span> any<span class="token punctuation">,</span> baseCtors<span class="token punctuation">:</span> any<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    baseCtors<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">baseCtor</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span>baseCtor<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">name</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            derivedCtor<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> baseCtor<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>理解这个例子
代码里首先定义了两个类，它们将做为mixins。
可以看到每个类都只定义了一个特定的行为或功能。 稍后我们使用它们来创建一个新类，同时具有这两种功能。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Disposable Mixin</span>
<span class="token keyword">class</span> <span class="token class-name">Disposable</span> <span class="token punctuation">{</span>
    isDisposed<span class="token punctuation">:</span> boolean<span class="token punctuation">;</span>
    <span class="token function">dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>isDisposed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token comment">// Activatable Mixin</span>
<span class="token keyword">class</span> <span class="token class-name">Activatable</span> <span class="token punctuation">{</span>
    isActive<span class="token punctuation">:</span> boolean<span class="token punctuation">;</span>
    <span class="token function">activate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>isActive <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">deactivate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>isActive <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>下面创建一个类，结合了这两个mixins。 下面来看一下具体是怎么操作的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">SmartObject</span> <span class="token keyword">implements</span> <span class="token class-name">Disposable</span><span class="token punctuation">,</span> Activatable <span class="token punctuation">{</span>
</code></pre></div><p>首先应该注意到的是，没使用extends而是使用implements。
把类当成了接口，仅使用Disposable和Activatable的类型而非其实现。
这意味着我们需要在类里面实现接口。
但是这是我们在用mixin时想避免的。</p> <p>我们可以这么做来达到目的，为将要mixin进来的属性方法创建出占位属性。
这告诉编译器这些成员在运行时是可用的。
这样就能使用mixin带来的便利，虽说需要提前定义一些占位属性。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Disposable</span>
isDisposed<span class="token punctuation">:</span> boolean <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token function-variable function">dispose</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token comment">// Activatable</span>
isActive<span class="token punctuation">:</span> boolean <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token function-variable function">activate</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token function-variable function">deactivate</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
</code></pre></div><p>最后，把mixins混入定义的类，完成全部实现部分。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">applyMixins</span><span class="token punctuation">(</span>SmartObject<span class="token punctuation">,</span> <span class="token punctuation">[</span>Disposable<span class="token punctuation">,</span> Activatable<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>最后，创建这个帮助函数，帮我们做混入操作。
它会遍历mixins上的所有属性，并复制到目标上去，把之前的占位属性替换成真正的实现代码。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">applyMixins</span><span class="token punctuation">(</span><span class="token parameter">derivedCtor<span class="token punctuation">:</span> any<span class="token punctuation">,</span> baseCtors<span class="token punctuation">:</span> any<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    baseCtors<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">baseCtor</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span>baseCtor<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">name</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            derivedCtor<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> baseCtor<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="模块">模块</h2> <p>// to do</p> <h2 id="模块解析">模块解析</h2> <h2 id="命名空间">命名空间</h2> <h2 id="命名空间和模块">命名空间和模块</h2> <h2 id="声明合并">声明合并</h2> <h2 id="jsx">JSX</h2> <h2 id="三斜线指令">三斜线指令</h2> <h2 id="javascript文件类型检查">JavaScript文件类型检查</h2></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">7/15/2019, 10:12:20 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/coding/typescript/1-quickStart.html" class="prev">
          快速上手
        </a></span> <span class="next"><a href="/coding/typescript/3-javascriptTranser.html">
          JavaScript迁移
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/coding/assets/js/app.bda66ca1.js" defer></script><script src="/coding/assets/js/2.5301b3be.js" defer></script><script src="/coding/assets/js/52.07abf413.js" defer></script>
  </body>
</html>
